<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>champly</title>
  
  <subtitle>To be or not to be is up to you</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-05-11T05:53:11.746Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>champly</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分布式系统</title>
    <link href="http://example.com/2023/05/01/architecture/distributed-systems/"/>
    <id>http://example.com/2023/05/01/architecture/distributed-systems/</id>
    <published>2023-05-01T01:31:26.000Z</published>
    <updated>2023-05-11T05:53:11.746Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>该文档主要是 <a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-824">mit 6.824</a> 课程的笔记以及一些扩展。</p></blockquote><h2 id="Distributed-Systems"><a href="#Distributed-Systems" class="headerlink" title="Distributed Systems"></a>Distributed Systems</h2><h3 id="Drivens-and-Challenges"><a href="#Drivens-and-Challenges" class="headerlink" title="Drivens and Challenges"></a>Drivens and Challenges</h3><p>分布式系统的核心是通过网络来协调，共同完成一致任务的一些计算机。包括大型网站的存储系统、大数据运算(MapReduce)。<em>在设计一个系统时或者面对一个需要解决的问题时，如果可以在一台计算机上解决，而不需要分布式系统，那就应该用一台计算机解决问题。很多的工作都可以在一台计算机上完成，并且通常比分布式系统简单很多。所以，在选择使用分布式系统解决问题之前，应该充分尝试别的思路，因为分布式系统会让问题解决变得复杂。</em></p><p>分布式系统会让问题的解决变得复杂，引入分布式系统的驱动力主要是：</p><ul><li>需要获得更高的计算性能：大量的并行运算、大量 CPU、大量内存、以及大量磁盘在并行的运行；</li><li>可以提供容错(tolerate faults)。比如两台计算机运行完全相同的任务，其中一台发生故障，可以切换到另外一台；</li><li>有一些问题天然在空间上就是分布式的。例如银行转账，本身就分布在不同的地域，这就需要一种两者之间协调的方法，所以有一些天然的原因导致系统是物理分布的；</li><li>构建分布式系统来达成一些安全的目标。比如有一些代码并不被信任，但是有需要和它进行交互，这些代码不会立即表现的恶意或者出现 Bug。你不会想要信任这些代码，所以想要将代码分散在多处运行，这样你的代码在另外一台计算机运行，我的代码在我的计算机上运行，通过一些特定的网络协议通信。所以，我们可能会担心安全问题，我们把系统分成多个的计算机，这样可以限制出错域。</li></ul><p>所有的这些分布式系统的问题在于：</p><ul><li>因为系统中存在很多部分，这些部分又在并发执行，会遇到并发编程和各种复杂交互所带来的问题，以及时间依赖的问题（同步、异步）。这让分布式系统变得很难；</li><li>分布式系统有多个组成部分，再加上计算机网络，会遇到一些意想不到的故障。如果只有一台计算机，那么它通常要么是工作，要么是故障或者没电，总的来说，要么是在工作，要么是没有工作。而由多台计算机组成的分布式系统，可能会有一部分组件在工作，而另一部分组件停止运行，或者这些计算机都正常运行，但是网络中断或者不稳定。所以，局部错误也是分布式系统很难的原因；</li><li>人们设计分布式系统的根本原因通常是为了获得更高的性能，比如一千台计算机或者一千个磁盘能达到的性能。但是实际上一千台机器到底有多少性能是一个棘手的问题，这里有很多难点，所以通常需要加倍小心的设计才能让系统达到你期望的性能。</li></ul><h3 id="Scalability"><a href="#Scalability" class="headerlink" title="Scalability"></a>Scalability</h3><p>通常来说，构建分布式系统的目的是为了获取人们常常提到的可扩展的加速。所以，追求的是可扩展性。而这里说的可扩展或者可扩展性指的是，如果用一台计算机解决了一些问题，当买了第二台计算机，只需要一半的时间就可以解决这些问题。两台计算机构成的系统如果两倍性能或者吞吐，就是这里说的可扩展性。</p><p>我们希望可以通过增加机器的方式来实现扩展，但是现实中这很难实现，需要一些架构设计来将这个可扩展性无限推进下去。</p><h3 id="Availability"><a href="#Availability" class="headerlink" title="Availability"></a>Availability</h3><p>如果只使用一台计算机构建系统，那么大概率是可靠的，因为一台计算机通常可以很好的运行很多年，计算机是可靠的，操作系统是可靠的。所以一台计算机正常工作很长时间并不少见，然而如果通过数千台计算机构建系统，对于这么多计算机，也会有很大概率的故障。所以大型分布式系统中有一个大问题，就是一些很罕见的问题会被放大。对于容错，有很多不同的概念可以表述，这些表述中，有一个共同的思想就是可用性。某些系统经过精心的设计，可以在特定的错误类型下，系统仍然能够正常运行，仍然像没有出现错误一样，提供完整的服务。</p><p>除了可用性之外，另一种容错性是自我可恢复性(recoverability)。如果出现了问题，服务会停止工作，不再响应请求，之后有人来修复，并且在修复之后系统仍然可以正常运行，就像没有出现过问题一样。这是一个比可用性更弱的需求，因为在出现故障到故障组件被修复期间，系统将完全停止工作，但是修复之后，系统又可以完全正确的重新运行，所以可恢复性是一个重要的需求。对于一个可恢复的系统，通常需要做一些操作，例如将最新的数据存在磁盘中，这样恢复供电之后，才能将这些数据取回来等。为了实现这些特性，有很多工具。其中最重要的有两个：</p><ul><li>非易失存储（non-volatile storage，类似磁盘）：这样当出现类似的电源故障，甚至整个机房电源故障，可以使用非易失存储。可以存放一些 checkpoint 或者系统状态的 log 在这些存储中，当故障修复之后，可以从硬盘中读出系统最新的状态，并从那个状态继续运行；</li><li>复制(replication)，不过，管理复制的多副本系统会有些棘手。任何一个多副本系统中，都会有一个关键问题，比如我们有两台服务器，本来运行着相同的系统状态，现在的关键问题在于，这两个副本总是会意外的偏离同步的状态，而不再互为副本。对于任何一种使用复制实现的容错系统，都会面临这个问题。</li></ul><h3 id="Consistency"><a href="#Consistency" class="headerlink" title="Consistency"></a>Consistency</h3><p>一致性就是用来定义操作行为的概念。之所以一致性是分布式系统中一个有趣的话题，是因为，从性能和容错的角度来说，我们通常会有多个副本。在一个非分布式系统中，通常只有一个服务器，一个表单。虽然不是绝对，但是通常来说对于 put&#x2F;get 的行为不会有歧义。直观上来说，put 就是更新这个表单，get 就是从表单中获取当前表单中存储的数据，但是在分布式系统中，由于复制或者缓存，数据可能存在于多个副本当中，于是就有了多个不同版本的数据。</p><p>实际上，对于一致性有很多不同的定义。有一些非常直观，比如说 get 请求可以得到最近一次完成的 put 请求写入的值。这种一般也被成为强一致（Strong Consistency）。但是，事实上，构建一个弱一致的系统也是非常有用的。弱一致是指不保证 get 请求可以得到最近一次完成的 put 请求写入的值。虽然强一致可以确保 get 获取的是最新的数据，但是实现这一点代价非常高，几乎可以确定的是，分布式系统的各个组件需要做大量的通信，才能实现强一致性。</p><h2 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h2><p>CAP 理论对分布式系统的特性做了高度抽象，有三个指标：</p><ul><li>Consistency：一致性强调的不是数据完整，而是各个节点间对数据一致；</li><li>Availability：可用性强调的是服务可用，但不保证数据的一致性；</li><li>Partition Tolerance：分区容错性强调的是集群对分区故障的容错能力。</li></ul><p>CAP 不可能都满足是对于一个分布式系统来说，只能在三个指标中选择其中两个。有网络交互就一定有延迟和数据丢失，而这种情况我们必须接受，还必须保证系统不能挂掉，所以 P 是必须要保证的，剩下的就只能在 C 和 A 中选一个。</p><h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><p>对于一个完整的 MapReduce Job，它由 Map Task 和一些 Reduce Task 组成:</p><ul><li>Job。整个 MapReduce 计算称为 Job；</li><li>Task。每一次 MapReduce 调用称为 Task。</li></ul><?xml version="1.0" encoding="us-ascii" standalone="no"?><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" height="521px" preserveAspectRatio="none" style="width:686px;height:521px;background:#FFFFFF;" version="1.1" viewBox="0 0 686 521" width="686px" zoomAndPan="magnify"><defs/><g><!--entity developer--><g id="elem_developer"><ellipse cx="341.8882" cy="14" fill="#F1F1F1" rx="8" ry="8" style="stroke:#181818;stroke-width:0.5;"/><path d="M341.8882,22 L341.8882,49 M328.8882,30 L354.8882,30 M341.8882,49 L328.8882,64 M341.8882,49 L354.8882,64 " fill="none" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="73" x="305.3882" y="78.4951">developer</text></g><!--entity master--><g id="elem_master"><rect fill="#F1F1F1" height="46.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="91" x="296.3882" y="158.5"/><rect fill="#F1F1F1" height="10" style="stroke:#181818;stroke-width:0.5;" width="15" x="367.3882" y="163.5"/><rect fill="#F1F1F1" height="2" style="stroke:#181818;stroke-width:0.5;" width="4" x="365.3882" y="165.5"/><rect fill="#F1F1F1" height="2" style="stroke:#181818;stroke-width:0.5;" width="4" x="365.3882" y="169.5"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="51" x="311.3882" y="191.4951">master</text></g><!--entity output--><g id="elem_output"><rect fill="#F1F1F1" height="36.2969" rx="35" ry="35" style="stroke:#181818;stroke-width:0.5;" width="69" x="319.3882" y="479.5"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="49" x="329.3882" y="502.4951">output</text></g><!--entity map1--><g id="elem_map1"><polygon fill="#F1F1F1" points="185.3882,275.5,195.3882,265.5,266.3882,265.5,266.3882,301.7969,256.3882,311.7969,185.3882,311.7969,185.3882,275.5" style="stroke:#181818;stroke-width:0.5;"/><line style="stroke:#181818;stroke-width:0.5;" x1="256.3882" x2="266.3882" y1="275.5" y2="265.5"/><line style="stroke:#181818;stroke-width:0.5;" x1="185.3882" x2="256.3882" y1="275.5" y2="275.5"/><line style="stroke:#181818;stroke-width:0.5;" x1="256.3882" x2="256.3882" y1="275.5" y2="311.7969"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="41" x="200.3882" y="298.4951">map1</text></g><!--entity map2--><g id="elem_map2"><polygon fill="#F1F1F1" points="69.8884,275.5,79.8884,265.5,149.8884,265.5,149.8884,301.7969,139.8884,311.7969,69.8884,311.7969,69.8884,275.5" style="stroke:#181818;stroke-width:0.5;"/><line style="stroke:#181818;stroke-width:0.5;" x1="139.8884" x2="149.8884" y1="275.5" y2="265.5"/><line style="stroke:#181818;stroke-width:0.5;" x1="69.8884" x2="139.8884" y1="275.5" y2="275.5"/><line style="stroke:#181818;stroke-width:0.5;" x1="139.8884" x2="139.8884" y1="275.5" y2="311.7969"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="40" x="84.8884" y="298.4951">map2</text></g><!--entity map3--><g id="elem_map3"><polygon fill="#F1F1F1" points="301.3882,275.5,311.3882,265.5,382.3882,265.5,382.3882,301.7969,372.3882,311.7969,301.3882,311.7969,301.3882,275.5" style="stroke:#181818;stroke-width:0.5;"/><line style="stroke:#181818;stroke-width:0.5;" x1="372.3882" x2="382.3882" y1="275.5" y2="265.5"/><line style="stroke:#181818;stroke-width:0.5;" x1="301.3882" x2="372.3882" y1="275.5" y2="275.5"/><line style="stroke:#181818;stroke-width:0.5;" x1="372.3882" x2="372.3882" y1="275.5" y2="311.7969"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="41" x="316.3882" y="298.4951">map3</text></g><!--entity map4--><g id="elem_map4"><polygon fill="#F1F1F1" points="417.8882,275.5,427.8882,265.5,497.8882,265.5,497.8882,301.7969,487.8882,311.7969,417.8882,311.7969,417.8882,275.5" style="stroke:#181818;stroke-width:0.5;"/><line style="stroke:#181818;stroke-width:0.5;" x1="487.8882" x2="497.8882" y1="275.5" y2="265.5"/><line style="stroke:#181818;stroke-width:0.5;" x1="417.8882" x2="487.8882" y1="275.5" y2="275.5"/><line style="stroke:#181818;stroke-width:0.5;" x1="487.8882" x2="487.8882" y1="275.5" y2="311.7969"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="40" x="432.8882" y="298.4951">map4</text></g><!--entity map5--><g id="elem_map5"><polygon fill="#F1F1F1" points="533.3882,275.5,543.3882,265.5,614.3882,265.5,614.3882,301.7969,604.3882,311.7969,533.3882,311.7969,533.3882,275.5" style="stroke:#181818;stroke-width:0.5;"/><line style="stroke:#181818;stroke-width:0.5;" x1="604.3882" x2="614.3882" y1="275.5" y2="265.5"/><line style="stroke:#181818;stroke-width:0.5;" x1="533.3882" x2="604.3882" y1="275.5" y2="275.5"/><line style="stroke:#181818;stroke-width:0.5;" x1="604.3882" x2="604.3882" y1="275.5" y2="311.7969"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="41" x="548.3882" y="298.4951">map5</text></g><!--entity reduce1--><g id="elem_reduce1"><polygon fill="#F1F1F1" points="207.8882,382.5,217.8882,372.5,305.8882,372.5,305.8882,408.7969,295.8882,418.7969,207.8882,418.7969,207.8882,382.5" style="stroke:#181818;stroke-width:0.5;"/><line style="stroke:#181818;stroke-width:0.5;" x1="295.8882" x2="305.8882" y1="382.5" y2="372.5"/><line style="stroke:#181818;stroke-width:0.5;" x1="207.8882" x2="295.8882" y1="382.5" y2="382.5"/><line style="stroke:#181818;stroke-width:0.5;" x1="295.8882" x2="295.8882" y1="382.5" y2="418.7969"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="58" x="222.8882" y="405.4951">reduce1</text></g><!--entity reduce2--><g id="elem_reduce2"><polygon fill="#F1F1F1" points="372.3882,382.5,382.3882,372.5,469.3882,372.5,469.3882,408.7969,459.3882,418.7969,372.3882,418.7969,372.3882,382.5" style="stroke:#181818;stroke-width:0.5;"/><line style="stroke:#181818;stroke-width:0.5;" x1="459.3882" x2="469.3882" y1="382.5" y2="372.5"/><line style="stroke:#181818;stroke-width:0.5;" x1="372.3882" x2="459.3882" y1="382.5" y2="382.5"/><line style="stroke:#181818;stroke-width:0.5;" x1="459.3882" x2="459.3882" y1="382.5" y2="418.7969"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="57" x="387.3882" y="405.4951">reduce2</text></g><!--link developer to master--><g id="link_developer_master"><path d="M341.8882,81.663 C341.8882,104.283 341.8882,132.68 341.8882,153.225 " fill="none" id="developer-to-master" style="stroke:#181818;stroke-width:2.0;"/><polygon fill="#181818" points="341.8882,158.271,345.8882,149.271,341.8882,153.271,337.8882,149.271,341.8882,158.271" style="stroke:#181818;stroke-width:2.0;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="19" x="342.8882" y="124.5669">job</text></g><!--link master to map1--><g id="link_master_map1"><path d="M317.5712,204.511 C299.1352,221.199 273.7512,244.176 254.3662,261.722 " fill="none" id="master-to-map1" style="stroke:#181818;stroke-width:1.0;stroke-dasharray:1.0,3.0;"/><polygon fill="#181818" points="250.5732,265.156,259.9306,262.0836,254.2808,261.8013,254.5631,256.1515,250.5732,265.156" style="stroke:#181818;stroke-width:1.0;"/></g><!--link master to map2--><g id="link_master_map2"><path d="M296.3292,203.119 C255.3712,221.657 195.5552,248.729 154.7972,267.175 " fill="none" id="master-to-map2" style="stroke:#181818;stroke-width:1.0;stroke-dasharray:1.0,3.0;"/><polygon fill="#181818" points="149.9242,269.381,159.7728,269.3138,154.4793,267.3192,156.4739,262.0257,149.9242,269.381" style="stroke:#181818;stroke-width:1.0;"/></g><!--link master to map3--><g id="link_master_map3"><path d="M341.8882,204.511 C341.8882,220.643 341.8882,242.651 341.8882,259.95 " fill="none" id="master-to-map3" style="stroke:#181818;stroke-width:1.0;stroke-dasharray:1.0,3.0;"/><polygon fill="#181818" points="341.8882,265.156,345.8882,256.156,341.8882,260.156,337.8882,256.156,341.8882,265.156" style="stroke:#181818;stroke-width:1.0;"/></g><!--link master to map4--><g id="link_master_map4"><path d="M366.2062,204.511 C384.6412,221.199 410.0252,244.176 429.4102,261.722 " fill="none" id="master-to-map4" style="stroke:#181818;stroke-width:1.0;stroke-dasharray:1.0,3.0;"/><polygon fill="#181818" points="433.2032,265.156,429.2152,256.1507,429.4963,261.8005,423.8465,262.0817,433.2032,265.156" style="stroke:#181818;stroke-width:1.0;"/></g><!--link master to map5--><g id="link_master_map5"><path d="M387.4472,203.119 C428.1522,221.542 487.4822,248.394 528.2202,266.831 " fill="none" id="master-to-map5" style="stroke:#181818;stroke-width:1.0;stroke-dasharray:1.0,3.0;"/><polygon fill="#181818" points="533.0942,269.037,526.5436,261.6824,528.5389,266.9757,523.2456,268.971,533.0942,269.037" style="stroke:#181818;stroke-width:1.0;"/></g><!--link master to reduce1--><g id="link_master_reduce1"><path d="M296.1692,188.863 C222.1412,200.207 81.3265,226.455 51.8884,265.5 C6,326.364 127.8816,365.713 202.9502,383.5 " fill="none" id="master-to-reduce1" style="stroke:#181818;stroke-width:1.0;stroke-dasharray:1.0,3.0;"/><polygon fill="#181818" points="207.8242,384.64,199.9715,378.6956,202.9556,383.5014,198.1498,386.4855,207.8242,384.64" style="stroke:#181818;stroke-width:1.0;"/></g><!--link master to reduce2--><g id="link_master_reduce2"><path d="M387.6072,188.863 C461.6362,200.207 602.4502,226.455 631.8882,265.5 C679.1222,328.149 551.4102,367.088 474.4452,384.245 " fill="none" id="master-to-reduce2" style="stroke:#181818;stroke-width:1.0;stroke-dasharray:1.0,3.0;"/><polygon fill="#181818" points="469.4512,385.343,479.1005,387.3157,474.3344,384.2686,477.3815,379.5026,469.4512,385.343" style="stroke:#181818;stroke-width:1.0;"/></g><!--link map1 to reduce1--><g id="link_map1_reduce1"><path d="M230.2282,311.58 C232.2802,321.156 234.9292,332.455 237.8882,342.5 C240.3172,350.746 243.3682,359.577 246.3102,367.578 " fill="none" id="map1-to-reduce1" style="stroke:#181818;stroke-width:1.0;"/><polygon fill="#181818" points="248.1212,372.44,248.7301,362.61,246.3769,367.7541,241.2327,365.4009,248.1212,372.44" style="stroke:#181818;stroke-width:1.0;"/></g><!--link map1 to reduce2--><g id="link_map1_reduce2"><path d="M266.5692,305.16 C303.7812,319.542 353.6832,338.994 357.8882,341.5 C370.7932,349.189 383.7192,359.497 394.4752,368.977 " fill="none" id="map1-to-reduce2" style="stroke:#181818;stroke-width:1.0;"/><polygon fill="#181818" points="398.3352,372.427,394.289,363.4477,394.6067,369.0956,388.9588,369.4133,398.3352,372.427" style="stroke:#181818;stroke-width:1.0;"/></g><!--link map2 to reduce1--><g id="link_map2_reduce1"><path d="M140.7044,311.511 C164.3412,328.395 196.9912,351.716 221.6622,369.338 " fill="none" id="map2-to-reduce1" style="stroke:#181818;stroke-width:1.0;"/><polygon fill="#181818" points="225.8602,372.337,220.861,363.8513,221.7913,369.4311,216.2115,370.3614,225.8602,372.337" style="stroke:#181818;stroke-width:1.0;"/></g><!--link map2 to reduce2--><g id="link_map2_reduce2"><path d="M150.0512,305.005 C156.0152,307.229 162.1012,309.454 167.8882,311.5 C236.2882,335.678 315.9062,361.405 367.2822,377.695 " fill="none" id="map2-to-reduce2" style="stroke:#181818;stroke-width:1.0;"/><polygon fill="#181818" points="372.1642,379.241,364.7922,372.71,367.3976,377.7312,362.3765,380.3366,372.1642,379.241" style="stroke:#181818;stroke-width:1.0;"/></g><!--link map3 to reduce1--><g id="link_map3_reduce1"><path d="M308.9652,311.707 C298.3262,320.089 287.1562,330.328 278.8882,341.5 C273.1382,349.27 268.5862,358.765 265.1502,367.559 " fill="none" id="map3-to-reduce1" style="stroke:#181818;stroke-width:1.0;"/><polygon fill="#181818" points="263.3562,372.358,270.2555,365.3295,265.1077,367.6748,262.7624,362.5271,263.3562,372.358" style="stroke:#181818;stroke-width:1.0;"/></g><!--link map3 to reduce2--><g id="link_map3_reduce2"><path d="M371.0132,311.684 C380.8072,320.206 391.1892,330.539 398.8882,341.5 C404.3962,349.342 408.8712,358.773 412.3112,367.492 " fill="none" id="map3-to-reduce2" style="stroke:#181818;stroke-width:1.0;"/><polygon fill="#181818" points="414.1162,372.248,414.6646,362.4144,412.3431,367.573,407.1845,365.2514,414.1162,372.248" style="stroke:#181818;stroke-width:1.0;"/></g><!--link map4 to reduce1--><g id="link_map4_reduce1"><path d="M417.6962,310.496 C384.8032,327.679 338.2342,352.006 303.6702,370.062 " fill="none" id="map4-to-reduce1" style="stroke:#181818;stroke-width:1.0;"/><polygon fill="#181818" points="299.0892,372.455,308.9184,371.8332,303.5209,370.1399,305.2142,364.7424,299.0892,372.455" style="stroke:#181818;stroke-width:1.0;"/></g><!--link map4 to reduce2--><g id="link_map4_reduce2"><path d="M450.4692,311.716 C447.2642,321.215 443.4412,332.419 439.8882,342.5 C437.0312,350.607 433.8512,359.397 430.9222,367.402 " fill="none" id="map4-to-reduce2" style="stroke:#181818;stroke-width:1.0;"/><polygon fill="#181818" points="429.1372,372.272,435.9913,365.1994,430.8586,367.5777,428.4803,362.4451,429.1372,372.272" style="stroke:#181818;stroke-width:1.0;"/></g><!--link map5 to reduce1--><g id="link_map5_reduce1"><path d="M533.1102,305.275 C527.3462,307.415 521.4802,309.545 515.8882,311.5 C445.7222,336.031 363.9122,361.778 311.3122,377.969 " fill="none" id="map5-to-reduce1" style="stroke:#181818;stroke-width:1.0;"/><polygon fill="#181818" points="306.3142,379.506,316.0925,380.683,311.0932,378.0359,313.7403,373.0366,306.3142,379.506" style="stroke:#181818;stroke-width:1.0;"/></g><!--link map5 to reduce2--><g id="link_map5_reduce2"><path d="M560.7872,311.663 C553.8112,322.043 544.4842,333.97 533.8882,342.5 C516.2902,356.667 494.2052,367.939 474.2382,376.316 " fill="none" id="map5-to-reduce2" style="stroke:#181818;stroke-width:1.0;"/><polygon fill="#181818" points="469.4802,378.275,479.3253,378.5482,474.1038,376.3718,476.2802,371.1504,469.4802,378.275" style="stroke:#181818;stroke-width:1.0;"/></g><!--link reduce1 to output--><g id="link_reduce1_output"><path d="M278.4162,418.6932 C294.9172,435.7046 317.5252,459.0126 333.6872,475.6737 " fill="none" id="reduce1-to-output" style="stroke:#181818;stroke-width:1.0;"/><polygon fill="#181818" points="337.2372,479.3343,333.8416,470.0893,333.7557,475.7455,328.0995,475.6597,337.2372,479.3343" style="stroke:#181818;stroke-width:1.0;"/></g><!--link reduce2 to output--><g id="link_reduce2_output"><path d="M406.0192,418.6932 C394.8132,435.4187 379.5292,458.2309 368.4082,474.828 " fill="none" id="reduce2-to-output" style="stroke:#181818;stroke-width:1.0;"/><polygon fill="#181818" points="365.3892,479.3343,373.7225,474.0848,368.1728,475.1808,367.0768,469.6311,365.3892,479.3343" style="stroke:#181818;stroke-width:1.0;"/></g><!--SRC=[TP5B3eCm30NtFeKlm89yDfNW8bKNb5YLge8ZQdh-GaaZiCZkUTv4jfIk5vumq8TU76c2deV88us2G_UM1RoNldiGyYnn5e2H0orTh7CoETcSN4u-FPaep3tL-y40vCNOD6rQUS4dtm6s0QjhO14AjwhTrfvpK-2sm5s1-zF5_-EBbLcVnHghWtm0wuNHQCDemsh3QiDfmsd3QyCV34ZD3wP_JTqEVG40]--></g></svg><p>MapReduce 展示了一个分布式系统的可扩展性。</p><h2 id="Replication"><a href="#Replication" class="headerlink" title="Replication"></a>Replication</h2><p>容错本身是为了提高可用性，当想构建一个服务时，尽管计算机硬件总是有可能故障，但是我们还是希望能稳定的提供服务，甚至出现了网络问题我们还是想能够提供服务。使用到的工具就是复制。最简单的方法来描述复制能处理的故障，就是单台计算机的 fail-stop 故障。不能解决软件中的 Bug 和硬件设计中的缺陷，还有另外一种情况，比如自然灾害，摧毁了整个数据中心，无论有多少副本都无济于事。如果我们想处理类似的问题，就需要将副本放在不同的城市，或者物理上把它们分开（同城双活、两地三中心架构）。另一个有关复制的问题是，这种复制的方案是否值得？这个不是一个可从技术上来回答的问题，这是一个经济上的问题，取决于一个可用服务的价值。</p><blockquote><p>所以任何技术都不是银弹，都是需要根据实际情况进行抉择和取舍。</p></blockquote><h3 id="State-Transfer"><a href="#State-Transfer" class="headerlink" title="State Transfer"></a>State Transfer</h3><p>状态转移背后的思想是，Primary 将自己完整状态，比如内存中的内容，拷贝并发送给 Backup。Backup 会保存收到的最近一次状态，所以 Backup 会有所有的数据。当 Primary 故障了，Backup 就可以从它所保存的最新状态开始运行。所以，状态转移就是发送Primary 的状态。</p><h3 id="Replicated-State-Machine"><a href="#Replicated-State-Machine" class="headerlink" title="Replicated State Machine"></a>Replicated State Machine</h3><p>复制状态机基于这个事实：我们想复制的大部分的服务或者计算机软件都有一些确定的内部操作，不确定的部分是外部输入。通常情况下，如果一台计算机没有外部影响，它只是一个接一个的执行命令，每条指令执行的是计算机中的内存和寄存器上的确定函数，只有当外部事件干预时，才会发生一些预期之外的事。例如某个随机事件收到了一个网络数据包，导致服务做了一些不同的事情。所以，复制状态机不会在不同的副本之间发送状态，相应的，它只会从 Primary 将这些外部事件，例如外部的输入，发送给 Backup。通常来说，如果有两台计算机，如果他们从相同的状态开始，并且它们以相同的顺序，在相同的事件，看到了相同的输入，那么它们会一直互为副本，并且保持一致。</p><blockquote><p>所以状态转移传输的可能是内存，而复制状态机会将来自客户端的操作或者其他外部事件，从 Primary 传输到 Backup。</p></blockquote><p>人们倾向于使用复制状态机的原因是，通常来说，外部操作或者事件比服务的状态要小。</p><h2 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h2><h3 id="Split-Brain"><a href="#Split-Brain" class="headerlink" title="Split Brain"></a>Split Brain</h3><p>尽管存在脑裂的可能，但是随着技术的发展，人们发现就算网络出现故障，可能出现分区，实际上是可以正确的实现能够自动完成故障切换的系统。当网络出现故障，将网络分割成两半，网络的两边独立运行，且不能访问对方，这通常被称为网络分区。在构建能自动恢复，同时又避免脑裂的多副本系统时，人们发现，关键点在于过半票决（Majority Vote）。</p><p>过半票决系统第一步在于，服务器的数量要是奇数，而不是偶数。在任何时候为了完成任何操作，必须凑够过半的服务器来批准相应的操作。</p><blockquote><p>如果系统有 2*F + 1 个服务器，那么系统最多可以接受 F 个服务器出现故障，仍然可以正常工作。</p></blockquote><p><a href="http://www.kailing.pub/raft/index.html">raft 共识算法动画演示</a></p><h3 id="AppendEntries"><a href="#AppendEntries" class="headerlink" title="AppendEntries"></a>AppendEntries</h3><?xml version="1.0" encoding="us-ascii" standalone="no"?><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" height="649px" preserveAspectRatio="none" style="width:852px;height:649px;background:#FFFFFF;" version="1.1" viewBox="0 0 852 649" width="852px" zoomAndPan="magnify"><defs/><g><rect fill="none" height="388.7266" style="stroke:#000000;stroke-width:1.5;" width="785.5" x="61" y="127.4297"/><rect fill="none" height="175.7969" style="stroke:#000000;stroke-width:1.5;" width="526.5" x="71" y="151.5625"/><rect fill="none" height="167.7969" style="stroke:#000000;stroke-width:1.5;" width="765.5" x="71" y="341.3594"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="29" x2="29" y1="81.2969" y2="568.2891"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="112" x2="112" y1="81.2969" y2="568.2891"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="229" x2="229" y1="81.2969" y2="568.2891"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="348.5" x2="348.5" y1="81.2969" y2="568.2891"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="43" x="5" y="77.9951">Client</text><ellipse cx="29.5" cy="13.5" fill="#E2E2F0" rx="8" ry="8" style="stroke:#181818;stroke-width:0.5;"/><path d="M29.5,21.5 L29.5,48.5 M16.5,29.5 L42.5,29.5 M29.5,48.5 L16.5,63.5 M29.5,48.5 L42.5,63.5 " fill="none" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="43" x="5" y="580.2842">Client</text><ellipse cx="29.5" cy="592.0859" fill="#E2E2F0" rx="8" ry="8" style="stroke:#181818;stroke-width:0.5;"/><path d="M29.5,600.0859 L29.5,627.0859 M16.5,608.0859 L42.5,608.0859 M29.5,627.0859 L16.5,642.0859 M29.5,627.0859 L42.5,642.0859 " fill="none" style="stroke:#181818;stroke-width:0.5;"/><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="63" x="81" y="50"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="49" x="88" y="69.9951">Leader</text><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="63" x="81" y="567.2891"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="49" x="88" y="587.2842">Leader</text><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="83" x="188" y="50"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="69" x="195" y="69.9951">Follower1</text><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="83" x="188" y="567.2891"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="69" x="195" y="587.2842">Follower1</text><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="82" x="307.5" y="50"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="68" x="314.5" y="69.9951">Follower2</text><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="82" x="307.5" y="567.2891"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="68" x="314.5" y="587.2842">Follower2</text><polygon fill="#181818" points="100.5,108.4297,110.5,112.4297,100.5,116.4297,104.5,112.4297" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="29.5" x2="106.5" y1="112.4297" y2="112.4297"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="49" x="36.5" y="107.3638">request</text><path d="M61,127.4297 L137,127.4297 L137,134.5625 L127,144.5625 L61,144.5625 L61,127.4297 " fill="#EEEEEE" style="stroke:#000000;stroke-width:1.5;"/><rect fill="none" height="388.7266" style="stroke:#000000;stroke-width:1.5;" width="785.5" x="61" y="127.4297"/><text fill="#000000" font-family="sans-serif" font-size="13" font-weight="bold" lengthAdjust="spacing" textLength="31" x="76" y="140.4966">raft</text><path d="M71,151.5625 L225,151.5625 L225,158.6953 L215,168.6953 L71,168.6953 L71,151.5625 " fill="#EEEEEE" style="stroke:#000000;stroke-width:1.5;"/><rect fill="none" height="175.7969" style="stroke:#000000;stroke-width:1.5;" width="526.5" x="71" y="151.5625"/><text fill="#000000" font-family="sans-serif" font-size="13" font-weight="bold" lengthAdjust="spacing" textLength="109" x="86" y="164.6294">AppendEntries</text><polygon fill="#181818" points="217.5,185.8281,227.5,189.8281,217.5,193.8281,221.5,189.8281" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="112.5" x2="223.5" y1="189.8281" y2="189.8281"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="93" x="119.5" y="184.7622">AppendEntries</text><polygon fill="#181818" points="336.5,214.9609,346.5,218.9609,336.5,222.9609,340.5,218.9609" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="112.5" x2="342.5" y1="218.9609" y2="218.9609"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="93" x="119.5" y="213.895">AppendEntries</text><polygon fill="#181818" points="123.5,244.0938,113.5,248.0938,123.5,252.0938,119.5,248.0938" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="117.5" x2="228.5" y1="248.0938" y2="248.0938"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="23" x="129.5" y="243.0278">Ack</text><polygon fill="#181818" points="123.5,273.2266,113.5,277.2266,123.5,281.2266,119.5,277.2266" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="117.5" x2="347.5" y1="277.2266" y2="277.2266"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="23" x="129.5" y="272.1606">Ack</text><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="112.5" x2="154.5" y1="306.3594" y2="306.3594"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="154.5" x2="154.5" y1="306.3594" y2="319.3594"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="113.5" x2="154.5" y1="319.3594" y2="319.3594"/><polygon fill="#181818" points="123.5,315.3594,113.5,319.3594,123.5,323.3594,119.5,319.3594" style="stroke:#181818;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="29" x="119.5" y="301.2935">Wait</text><path d="M162,293.7266 L162,318.7266 L582,318.7266 L582,303.7266 L572,293.7266 L162,293.7266 " fill="#FFAAAA" style="stroke:#181818;stroke-width:0.5;"/><path d="M572,293.7266 L572,303.7266 L582,303.7266 L572,293.7266 " fill="#FFAAAA" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="399" x="168" y="310.7935">&#31561;&#24453;&#36807;&#21322;&#33410;&#28857;&#21709;&#24212;&#65288;&#21253;&#25324;&#33258;&#24049;&#65289;&#65292;&#36825;&#37324;&#21482;&#38656;&#35201;&#31561;&#24453;&#19968;&#20010; Follower &#21709;&#24212;</text><path d="M71,341.3594 L174,341.3594 L174,348.4922 L164,358.4922 L71,358.4922 L71,341.3594 " fill="#EEEEEE" style="stroke:#000000;stroke-width:1.5;"/><rect fill="none" height="167.7969" style="stroke:#000000;stroke-width:1.5;" width="765.5" x="71" y="341.3594"/><text fill="#000000" font-family="sans-serif" font-size="13" font-weight="bold" lengthAdjust="spacing" textLength="58" x="86" y="354.4263">commit</text><polygon fill="#181818" points="217.5,375.625,227.5,379.625,217.5,383.625,221.5,379.625" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="112.5" x2="223.5" y1="379.625" y2="379.625"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="93" x="119.5" y="374.5591">AppendEntries</text><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="229.5" x2="271.5" y1="412.8242" y2="412.8242"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="271.5" x2="271.5" y1="412.8242" y2="425.8242"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="230.5" x2="271.5" y1="425.8242" y2="425.8242"/><polygon fill="#181818" points="240.5,421.8242,230.5,425.8242,240.5,429.8242,236.5,425.8242" style="stroke:#181818;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="105" x="236.5" y="407.7583">judge commit ID</text><path d="M353,392.625 L353,432.625 L821,432.625 L821,402.625 L811,392.625 L353,392.625 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M811,392.625 L811,402.625 L821,402.625 L811,392.625 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="296" x="359" y="409.6919">Leader &#20250;&#23558;&#26356;&#22823;&#30340; commit ID &#21457;&#36865;&#32473; Follower&#65292;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="447" x="359" y="424.8247">&#24403;&#20854;&#20182;&#21103;&#26412;&#25910;&#21040;&#20102;&#36825;&#20010;&#28040;&#24687;&#23601;&#30693;&#36947;&#20043;&#21069;&#25552;&#20132;&#30340; commit &#21495;&#24050;&#32463;&#34987; Leader &#25552;&#20132;</text><polygon fill="#181818" points="336.5,455.0234,346.5,459.0234,336.5,463.0234,340.5,459.0234" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="112.5" x2="342.5" y1="459.0234" y2="459.0234"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="93" x="119.5" y="453.9575">AppendEntries</text><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="348.5" x2="390.5" y1="488.1563" y2="488.1563"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="390.5" x2="390.5" y1="488.1563" y2="501.1563"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="349.5" x2="390.5" y1="501.1563" y2="501.1563"/><polygon fill="#181818" points="359.5,497.1563,349.5,501.1563,359.5,505.1563,355.5,501.1563" style="stroke:#181818;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="105" x="355.5" y="483.0903">judge commit ID</text><polygon fill="#181818" points="40.5,543.2891,30.5,547.2891,40.5,551.2891,36.5,547.2891" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="34.5" x2="111.5" y1="547.2891" y2="547.2891"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="59" x="46.5" y="542.2231">response</text><path d="M117,528.1563 L117,553.1563 L559,553.1563 L559,538.1563 L549,528.1563 L117,528.1563 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M549,528.1563 L549,538.1563 L559,538.1563 L549,528.1563 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="421" x="123" y="545.2231">&#31561;&#24453; commit &#36820;&#22238;&#20449;&#24687;&#65292;&#22914;&#26524;&#26377;&#36807;&#21322;&#33410;&#28857;&#21709;&#24212;&#65292;&#21017;&#36820;&#22238;&#25104;&#21151;&#65292;&#21542;&#21017;&#20250;&#37325;&#35797;</text><!--SRC=[dLF1Rjf04BtlLwpKSmxbs4Car1OfKkyzMx2bRedjBejw1LI2JK2cWaGYGObIfKGYYI1L1GdGyZEUjNtY5xh6nh65ApMTsyw-UM_cpQwKPIh5BmioKHZI9ChahAn92iDlY9GZD9RAg8M2-fdGvudP548-3TxPsGtAyGjCoQSIAJAKfsf9mrHwnn0MuH_JcaQKt6k5KPaKrtalWbgF9fGKJFyCJlqL_4WNwp6T_RW5IMr3aZH3m5j9PY50KHd1LCw_P_XP9fCM4LvvOTyQyBlcBElGQZYDgbrzW4uBPjtLGeTcZH_UEFKXJEzM2sErQ3hBdbjlWZbq-sLdKF5hhVkoTJyCcyL-VIWYHb_tW883YdYULVVt8wq-oUouVr7yXr8kJm9klFSgmOcO0u6gjJY1yG4__GcNL_R9byTw3EPNjronvxrGHLWHeu1V7QXDhFan62FUl-7T2UXZQtOW_1BMy8dEAoCOtzddtzrAnteu1AF5pROrkum8WJc5wGzxRZhVhZSz-Q1aA__xmQMsy4c6UPjQRokY4VmfxoCLDLKf4XInr7yC6nPdsONJCsjv8IONRi6Woi_wl6yaFRGcw3qVp_KsDCwzJ7iWac8bRhtbZ8xGPl8_]--></g></svg><h3 id="Leader-Election"><a href="#Leader-Election" class="headerlink" title="Leader Election"></a>Leader Election</h3><?xml version="1.0" encoding="us-ascii" standalone="no"?><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" height="323px" preserveAspectRatio="none" style="width:561px;height:323px;background:#FFFFFF;" version="1.1" viewBox="0 0 561 323" width="561px" zoomAndPan="magnify"><defs/><g><g id="Follower"><rect fill="#F1F1F1" height="50" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="80" x="122.9699" y="13.276"/><line style="stroke:#181818;stroke-width:0.5;" x1="122.9699" x2="202.9699" y1="39.5729" y2="39.5729"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="60" x="132.9699" y="31.2711">Follower</text></g><g id="Candidate"><rect fill="#F1F1F1" height="50" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="93" x="100.4699" y="140.276"/><line style="stroke:#181818;stroke-width:0.5;" x1="100.4699" x2="193.4699" y1="166.5729" y2="166.5729"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="73" x="110.4699" y="158.2711">Candidate</text></g><g id="Leader"><rect fill="#F1F1F1" height="50" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="69" x="284.4699" y="267.276"/><line style="stroke:#181818;stroke-width:0.5;" x1="284.4699" x2="353.4699" y1="293.5729" y2="293.5729"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="49" x="294.4699" y="285.2711">Leader</text></g><ellipse cx="23.9699" cy="38.276" fill="#181818" rx="10" ry="10" style="stroke:none;stroke-width:1.0;"/><!--link *start* to Follower--><g id="link_*start*_Follower"><path d="M34.4175,38.276 C51.9049,38.276 88.0925,38.276 117.6309,38.276 " fill="none" id="*start*-to-Follower" style="stroke:#181818;stroke-width:1.0;"/><polygon fill="#181818" points="122.6849,38.276,113.6849,34.276,117.6849,38.276,113.6849,42.276,122.6849,38.276" style="stroke:#181818;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="52" x="52.4699" y="31.3429">&#21021;&#22987;&#29366;&#24577;</text></g><!--link Follower to Candidate--><g id="link_Follower_Candidate"><path d="M122.6969,43.278 C90.8141,48.804 48.2308,61.959 26.9699,93.276 C6,124.165 53.8527,143.605 95.2131,154.18 " fill="none" id="Follower-to-Candidate" style="stroke:#181818;stroke-width:1.0;"/><polygon fill="#181818" points="100.2198,155.426,92.4518,149.3713,95.3677,154.2188,90.5202,157.1346,100.2198,155.426" style="stroke:#181818;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="91" x="27.9699" y="106.3429">&#36229;&#26102;&#65292;&#24320;&#22987;&#36873;&#20030;</text></g><!--link Candidate to Follower--><g id="link_Candidate_Follower"><path d="M150.0449,140.249 C152.6659,119.779 156.4389,90.297 159.2329,68.47 " fill="none" id="Candidate-to-Follower" style="stroke:#181818;stroke-width:1.0;"/><polygon fill="#181818" points="159.8849,63.377,154.7755,71.7969,159.2506,68.3366,162.7109,72.8117,159.8849,63.377" style="stroke:#181818;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="236" x="156.9699" y="106.3429">&#20986;&#29616; Leader &#25110;&#32773;&#20986;&#29616;&#26356;&#39640;&#30340;&#20219;&#26399;(term)</text></g><!--link Candidate to Candidate--><g id="link_Candidate_Candidate"><path d="M193.8709,153.722 C212.6809,153.069 228.4699,156.921 228.4699,165.276 C228.4699,172.848 215.5029,176.721 199.0709,176.895 " fill="none" id="Candidate-to-Candidate" style="stroke:#181818;stroke-width:1.0;"/><polygon fill="#181818" points="193.8709,176.83,202.8198,180.9429,198.8705,176.8929,202.9204,172.9435,193.8709,176.83" style="stroke:#181818;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="130" x="234.4699" y="169.8429">&#36229;&#26102;&#65292;&#36827;&#34892;&#26032;&#19968;&#36718;&#36873;&#20030;</text></g><!--link Candidate to Leader--><g id="link_Candidate_Leader"><path d="M180.1329,190.377 C209.1629,211.474 251.3059,242.1019 281.5379,264.0722 " fill="none" id="Candidate-to-Leader" style="stroke:#181818;stroke-width:1.0;"/><polygon fill="#181818" points="285.9079,267.2487,280.9797,258.7215,281.8634,264.3089,276.276,265.1926,285.9079,267.2487" style="stroke:#181818;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="117" x="244.9699" y="233.3429">&#25910;&#21040;&#36807;&#21322;&#26381;&#21153;&#30340;&#25237;&#31080;</text></g><!--link Leader to Follower--><g id="link_Leader_Follower"><path d="M347.4589,267.1905 C356.1289,258.5536 364.9469,248.2231 370.9699,237.276 C498.2109,6 424.1239,120.994 401.9699,93.276 C378.2039,63.541 270.8589,48.99 208.4109,42.925 " fill="none" id="Leader-to-Follower" style="stroke:#181818;stroke-width:1.0;"/><polygon fill="#181818" points="203.2529,42.433,211.8329,47.2685,208.2303,42.9072,212.5916,39.3046,203.2529,42.433" style="stroke:#181818;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="132" x="421.9699" y="169.8429">&#25910;&#21040;&#26356;&#39640;&#30340;&#20219;&#26399;(term)</text></g><!--SRC=[Aov9B4bLSClFoSalJotYAWPpdHFpKZ9JW2metoSrCGKeoHMj5QkWQmTNhM2byBHZxjFbtS-xjZrhQEI2Y-i25S7D0AfwiQtrsVHjx_VqFDtJ05J-ig7poOvzN0WLEDM_s3_xnSAUPzCsFDdHy6BlEgmQ8Ou3wdesPTlJZWqlzhS_xUrwDgVtQTV2vxDQddLDVRvq1HTKaIwgwo4wditUydBr3A3Q9xjtFvipNwCajIXN4yqIP2-txthUjm5cxREEQIyQMY5YM0q20000]--></g></svg><ul><li>系统启动时，默认都是 Follower 状态，初始化时会随机赋予一个时间(150~300ms)，当超时之后会转换为 Candidate 状态，发起一轮投票；</li><li>Candidate 是选主过程中的中间状态，只有大多数 Follower 投票通过时，才会转换为 Leader；</li><li>如果 Candidate 选主超时，则会发起新一轮选主过程（当前 term 会加一）；</li><li>如果 Candidate 收到 Leader 发来的信息时，会转换为 Follower；</li><li>Follower 在一个任期（term）过程中，只会给一个 Candidate 投票，投票之后会重置超时时间；</li><li>Candidate 和 Leader 在发现更大的任期时，都会转换为 Follower。</li></ul><h3 id="Election-Restriction"><a href="#Election-Restriction" class="headerlink" title="Election Restriction"></a>Election Restriction</h3><p>Follower 只能向满足下面条件之一的 Candidate 投票:</p><ul><li>Candidate 最后一条 Log 条目的任期号大于本地最后一条 Log 条目的任期号；</li><li>Candidate 最后一条 Log 条目的任期号等于本地最后一条 Log 条目的任期号，并且 Candidate 的 Log 长度大于或等于本地 Log 记录的长度。</li></ul><h3 id="Log-Backup"><a href="#Log-Backup" class="headerlink" title="Log Backup"></a>Log Backup</h3><p>Leader 中的日志只能追加，Leader 会强制让 Follower 的数据和自己保持一致。Leader 为每个 Follower 维护了 nextIndex，nextIndex 的初始值是从新任的最后一条日志开始。AppendEntries 消息包含了 prevLogIndex 和 prevLogTerm 字段，这样的 AppendEntries 消息发送给了 Follower。而 Follower 它们在收到 AppendEntries 消息时，可以知道它们收到一个带有若干 Log 条目的消息，Follower 在写入 Log 之前，会检查本地的前一个 Log 条目，是否与 Leader 发来的 prevLogIndex 信息匹配。如果不匹配，Followers 会拒绝。为了响应 Follower 返回的拒绝，Leader 会减少对应的 nextIndex，直到匹配，才会把数据写入本地（新增或者修改）。</p><p>这样一个一个回退的过程太慢了，可以让 Follower 在返回消息的时候多返回一些信息，就可以加速恢复：</p><ul><li>XTerm：这个是 Follower 中与 Leader 冲突的 Log 对应的任期号，如果 Follower 在对应位置的任期号不匹配，它会拒绝 Leader 的 AppendEntries 消息，并将自己的任期号放在 XTerm 中。如果 Follower 在对应位置没有 Log，那么会返回 -1；</li><li>XIndex：这个是 Follower 中，对应任期号为 XTerm 的第一条 Log 条目的槽位号；</li><li>XLen：如果 Follower 在对应位置没有 Log，那么 XTerm 会返回 -1，XLen 表示空白的 Log 槽位数。</li></ul><p>还可以通过日志快照（Log Snapshot）的方式来快速恢复：当 Follower 刚恢复，如果它的 Log 已经很滞后了，那么它会首先强制 Leader 回退自己的 Log，在某个点，Leader 将不能再回退，因为已经到了自己 Log 的起点，这个时候 Leader 会将自己的快照发给 Follower，滞后立即通过 AppendEntries 将后面的 Log 发给 Follower。</p><h2 id="Linearizability"><a href="#Linearizability" class="headerlink" title="Linearizability"></a>Linearizability</h2><p>通常来说，线性一致等价于强一致，一个服务是线性一致的，那么它表现的就像只有一个服务器，并且服务器没有故障，这个服务器每次执行一个客户端请求，并且没有什么奇怪的事情发生。要达到线性一致性，我们现在要确定顺序，对于这个顺序，有两个限制条件：</p><ul><li>如果一个操作在另一个操作开始前就结束了，那么这个操作必须在执行历史中出现在另一个操作前面；</li><li>执行历史中，读操作，必须在相应的 key 的写操作之后。</li></ul><p>如果我们能构建这么一个序列，那么可以证明，这里的请求历史记录是线性的，必须同时满足：</p><ul><li>序列中的请求的顺序与实际时间匹配；</li><li>每个读请求看到的都是序列中前一个写请求写入的值。</li></ul><h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><p>相比 Raft 来说，Raft 实际上就是一个库。可以在更大的多副本系统中使用 Raft 库。但是 Raft 不是一个你可以直接交互的独立服务，你必须要设计你自己的应用程序来与 Raft 库交互。Zookeeper 作为一个多副本系统，是一个容错的、通用的协调服务，它与其他系统一样，通过多副本来完成容错。</p><p>Zookeeper 和 Raft 类似，先发出 Log 条目之后，当 Leader 收到了过半服务器当回复，Leader 就会发送 commit 消息。Zookeeper 的读性能随着服务器数量的增加而显著的增加。所以很明显，Zookeeper 在这里有一些修改使得读请求可以由其他副本来处理。那么 Zookeeper 是如何确保这里的读请求是安全的（线性一致）？</p><p>实际上，Zookeeper 并不要求返回最新的写入数据。Zookeeper 的方式是，放弃线性一致性，不提供线性一致的读。所以 Zookeeper 也不用为读请求提供最新的数据，它由自己有关一致性的定义，而这个定义不是线性一致的，因此允许读请求返回旧的数据。所以 Zookeeper 这里声明自己最开始就不支持线性一致性，来解决这里的技术问题。如果不提供这个能力，那么读请求返回旧的数据。这里实际上是一种经典的解决性能和强一致之间矛盾的方法，也就是不提供强一致。</p><p>这里的工作原理是，每个 Log 条目都会被 Leader 打上 zxid 的标签，这些标签就是 Log 对应的条目号。任何时候一个副本回复一个客户端的读请求，首先这个读请求是在 Log 的某个特定点执行的，其次回复里面会带上 zxid，对应的就是 Log 执行点的前一条 Log 条目。客户端会记住最高 zxid，当客户端发出一个请求到一个相同或者不同的副本时，它会在它的请求中带上这个最高的 zxid。这样，其他副本就知道，应该至少在 Log 中这个点或者之后执行读请求。那么在获取到对应这个位置的 Log 之前，这个副本是不能响应客户端请求。</p><h2 id="Quorum-Replication"><a href="#Quorum-Replication" class="headerlink" title="Quorum Replication"></a>Quorum Replication</h2><p>假设有 N 个副本，为了能够执行写请求，必须要确保写操作被 W 个副本确认，W 小于 N。所以你需要将写入请求发送到这 W 个副本。如果要执行读请求，那么至少需要从 R 个副本得到所读取的信息。这里的 W 对应的数字成为 Write Quorum，R 对应的数字成为 Read Quorum。Quorum 系统要求，任意你要发送写请求的 W 个服务器，必须与任意接受读取请求的 R 个服务器由重叠。意味着，<code>R + W</code> 必须大于 N（至少满足 <code>R + W = N + 1</code>）。这样任意 W 个服务器至少与任意 R 个服务器有一个重合。</p><p>还有一个关键点，客户端读取请求可能会得到 R 个不同的结果，需要通过最高版本号（Version）的数值作为结果。当 R 为 1 时，写请求就不再是容错的了，W 为 1 时，读请求不再是容错的，都必须要求所有的服务器在线。</p><blockquote><p>可以通过调整 W 和 R 来提升服务的写性能或者读性能。</p></blockquote><h2 id="Distributed-Transaction"><a href="#Distributed-Transaction" class="headerlink" title="Distributed Transaction"></a>Distributed Transaction</h2><p>可以这么理解事务：程序员有一些不同的操作，或许针对数据库不同记录，他们希望所有这些操作作为一个整体，不会因为失败而被分割，也不会被其他活动看到中间状态。事务处理系统要求程序员对这些读操作、写操作标明起始和结束，这样才能知道事务起始和结束。事务处理系统可以保证在事务的开始和结束之间的行为是可预期的。数据库通常对于正确性有一个概念称为 ACID:</p><ul><li>Atomic，原子性。意味着事务可能有多个步骤，比如写多个数据记录，尽管可能存在故障，但是要么所有的写数据都完成了，要么没有写数据能完成。不应该发生类似的这种情况：在一个特定的时间发生了故障，导致事务中一半的写数据完成并可见，另一半的写数据没有完成，这里要么全有，要么全没有（All or Nothing）；</li><li>Consistent，一致性。它通常是指数据库会强制某些应用程序定义的数据不变；</li><li>Isolated，隔离性。这是一个属性，表明两个同时运行的事务，在事务结束前，能不能看到彼此的更新，能不能看到另一个事务中间的临时的更新。目标是不能，隔离在技术上的具体体现是，事务需要串行执行。事务不能看到彼此之间的中间状态，只能看到完成的事务结果；</li><li>Durable，持久化。意味着在事务提交之后，数据库中的修改是持久化的，不会应为一些错误而被擦除。这意味着数据要被写入到一些非易失的存储（Non-Volatile Storage），持久化的存储，例如磁盘。</li></ul><p>通常来说，隔离性意味着可序列化（Serializable）。它的定义是如果在同一时间并行的事务，那么可以生成一系列的结果。这里的结果包含：</p><ul><li>由任何事务中的修改行为产生的数据库记录的修改；</li><li>任何事务生成的输出。</li></ul><p>我们说可序列化是指，并行的执行一些事务得到的结果，与按照某种串行的顺序来执行这些事务，可以得到相同的结果。实际的执行过程或许有大量的并行处理，但是这里要求得到的结果与按照某种顺序一次一个事务的串行执行结果是一样的。所以，如果检查一个并发事务执行是否是可序列化的，可以查看结果，并看看是否可以找到对于同一些事务，存在一次只执行一个事务的顺序，按照这个顺序执行可以生成相同的结果。</p><blockquote><p>现实中隔离性要看数据库配置的隔离级别: <a href="https://cloud.tencent.com/developer/beta/article/1833688">数据库事务隔离级别</a>。</p></blockquote><h3 id="Concurrency-Control"><a href="#Concurrency-Control" class="headerlink" title="Concurrency Control"></a>Concurrency Control</h3><p>在并发控制中，主要有两种策略:</p><ul><li>悲观并发控制（Pessimistic Concurrency Control）: 在事务使用任何数据之前，它需要获得数据的锁，如果有一些其他的事务已经在使用这里的数据，锁会被它们持有，当前事务必须等待这些事务结束，之后当前事务才能获取到锁。在悲观系统中，如果由锁冲突，就会造成延时等待；</li><li>乐观并发控制（Optimistic Concurrency Control）: 基本思想是，你不用担心其他事务是否正在读写你要使用的数据，你直接继续执行你的读写操作，通常来说这些执行会在一些临时区域，只有在事务最后的时候，再检查是不是有一些其他事务干扰了你。如果没有就可以完成事务，并且不需要承受锁带来的性能损耗，因为操作锁的代价一般都比较高；如果有一些其他的事务在同一时间修改了你关心的数据，造成了冲突，那么就必须 Abort 掉当前事务，并重试。</li></ul><p>具体使用哪种策略应该取决于不同的环境，如果冲突非常频繁，或许用悲观并发控制更好一些。悲观控制的锁就是两阶段锁（Two-Phase Locking）。</p><h3 id="Two-Phase-Commit"><a href="#Two-Phase-Commit" class="headerlink" title="Two-Phase Commit"></a>Two-Phase Commit</h3><?xml version="1.0" encoding="us-ascii" standalone="no"?><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" height="1334px" preserveAspectRatio="none" style="width:417px;height:1334px;background:#FFFFFF;" version="1.1" viewBox="0 0 417 1334" width="417px" zoomAndPan="magnify"><defs/><g><rect fill="none" height="145.3359" style="stroke:#000000;stroke-width:1.5;" width="220.5" x="170" y="98.2969"/><rect fill="none" height="191.9297" style="stroke:#000000;stroke-width:1.5;" width="220.5" x="170" y="257.6328"/><rect fill="#90EE90" height="773.125" style="stroke:#000000;stroke-width:1.5;" width="400.5" x="10" y="463.5625"/><rect fill="none" height="356.5938" style="stroke:#000000;stroke-width:1.5;" width="380.5" x="20" y="487.6953"/><rect fill="none" height="75.3984" style="stroke:#000000;stroke-width:1.5;" width="152.5" x="170" y="583.0938"/><rect fill="none" height="75.3984" style="stroke:#000000;stroke-width:1.5;" width="186.5" x="170" y="672.4922"/><rect fill="none" height="75.3984" style="stroke:#000000;stroke-width:1.5;" width="220.5" x="170" y="761.8906"/><rect fill="#FFC0CB" height="385.3984" style="stroke:none;stroke-width:1.0;" width="400.5" x="10" y="851.2891"/><rect fill="none" height="356.5938" style="stroke:#000000;stroke-width:1.5;" width="380.5" x="20" y="873.0938"/><rect fill="none" height="75.3984" style="stroke:#000000;stroke-width:1.5;" width="152.5" x="170" y="968.4922"/><rect fill="none" height="75.3984" style="stroke:#000000;stroke-width:1.5;" width="186.5" x="170" y="1057.8906"/><rect fill="none" height="75.3984" style="stroke:#000000;stroke-width:1.5;" width="220.5" x="170" y="1147.2891"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="54" x2="54" y1="81.2969" y2="202.8281"/><line style="stroke:#A80036;stroke-width:1.0;stroke-dasharray:1.0,4.0;" x1="54" x2="54" y1="202.8281" y2="243.6328"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="54" x2="54" y1="243.6328" y2="1253.6875"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="196" x2="196" y1="81.2969" y2="202.8281"/><line style="stroke:#A80036;stroke-width:1.0;stroke-dasharray:1.0,4.0;" x1="196" x2="196" y1="202.8281" y2="243.6328"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="196" x2="196" y1="243.6328" y2="1253.6875"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="300.5" x2="300.5" y1="81.2969" y2="202.8281"/><line style="stroke:#A80036;stroke-width:1.0;stroke-dasharray:1.0,4.0;" x1="300.5" x2="300.5" y1="202.8281" y2="243.6328"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="300.5" x2="300.5" y1="243.6328" y2="1253.6875"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="334.5" x2="334.5" y1="81.2969" y2="202.8281"/><line style="stroke:#A80036;stroke-width:1.0;stroke-dasharray:1.0,4.0;" x1="334.5" x2="334.5" y1="202.8281" y2="243.6328"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="334.5" x2="334.5" y1="243.6328" y2="1253.6875"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="368.5" x2="368.5" y1="81.2969" y2="202.8281"/><line style="stroke:#A80036;stroke-width:1.0;stroke-dasharray:1.0,4.0;" x1="368.5" x2="368.5" y1="202.8281" y2="243.6328"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="368.5" x2="368.5" y1="243.6328" y2="1253.6875"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="43" x="30" y="77.9951">Client</text><ellipse cx="54.5" cy="13.5" fill="#E2E2F0" rx="8" ry="8" style="stroke:#181818;stroke-width:0.5;"/><path d="M54.5,21.5 L54.5,48.5 M41.5,29.5 L67.5,29.5 M54.5,48.5 L41.5,63.5 M54.5,48.5 L67.5,63.5 " fill="none" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="43" x="30" y="1265.6826">Client</text><ellipse cx="54.5" cy="1277.4844" fill="#E2E2F0" rx="8" ry="8" style="stroke:#181818;stroke-width:0.5;"/><path d="M54.5,1285.4844 L54.5,1312.4844 M41.5,1293.4844 L67.5,1293.4844 M54.5,1312.4844 L41.5,1327.4844 M54.5,1312.4844 L67.5,1327.4844 " fill="none" style="stroke:#181818;stroke-width:0.5;"/><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="33" x="180" y="50"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="19" x="187" y="69.9951">TC</text><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="33" x="180" y="1252.6875"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="19" x="187" y="1272.6826">TC</text><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="24" x="288.5" y="50"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="10" x="295.5" y="69.9951">A</text><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="24" x="288.5" y="1252.6875"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="10" x="295.5" y="1272.6826">A</text><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="24" x="322.5" y="50"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="10" x="329.5" y="69.9951">B</text><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="24" x="322.5" y="1252.6875"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="10" x="329.5" y="1272.6826">B</text><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="24" x="356.5" y="50"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="10" x="363.5" y="69.9951">C</text><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="24" x="356.5" y="1252.6875"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="10" x="363.5" y="1272.6826">C</text><path d="M170,98.2969 L284,98.2969 L284,105.4297 L274,115.4297 L170,115.4297 L170,98.2969 " fill="#EEEEEE" style="stroke:#000000;stroke-width:1.5;"/><rect fill="none" height="145.3359" style="stroke:#000000;stroke-width:1.5;" width="220.5" x="170" y="98.2969"/><text fill="#000000" font-family="sans-serif" font-size="13" font-weight="bold" lengthAdjust="spacing" textLength="69" x="185" y="111.3638">operator</text><polygon fill="#181818" points="288.5,132.5625,298.5,136.5625,288.5,140.5625,292.5,136.5625" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="196.5" x2="294.5" y1="136.5625" y2="136.5625"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="21" x="203.5" y="131.4966">get</text><polygon fill="#181818" points="322.5,161.6953,332.5,165.6953,322.5,169.6953,326.5,165.6953" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="196.5" x2="328.5" y1="165.6953" y2="165.6953"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="20" x="203.5" y="160.6294">set</text><polygon fill="#181818" points="356.5,190.8281,366.5,194.8281,356.5,198.8281,360.5,194.8281" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="196.5" x2="362.5" y1="194.8281" y2="194.8281"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="20" x="203.5" y="189.7622">set</text><text fill="#000000" font-family="sans-serif" font-size="11" lengthAdjust="spacing" textLength="80" x="171.5" y="227.0386">multi operator</text><path d="M170,257.6328 L274,257.6328 L274,264.7656 L264,274.7656 L170,274.7656 L170,257.6328 " fill="#EEEEEE" style="stroke:#000000;stroke-width:1.5;"/><rect fill="none" height="191.9297" style="stroke:#000000;stroke-width:1.5;" width="220.5" x="170" y="257.6328"/><text fill="#000000" font-family="sans-serif" font-size="13" font-weight="bold" lengthAdjust="spacing" textLength="59" x="185" y="270.6997">prepare</text><polygon fill="#181818" points="288.5,291.8984,298.5,295.8984,288.5,299.8984,292.5,295.8984" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="196.5" x2="294.5" y1="295.8984" y2="295.8984"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="50" x="203.5" y="290.8325">Prepare</text><polygon fill="#181818" points="207.5,321.0313,197.5,325.0313,207.5,329.0313,203.5,325.0313" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="201.5" x2="299.5" y1="325.0313" y2="325.0313"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="44" x="213.5" y="319.9653">Yes/No</text><polygon fill="#181818" points="322.5,350.1641,332.5,354.1641,322.5,358.1641,326.5,354.1641" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="196.5" x2="328.5" y1="354.1641" y2="354.1641"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="50" x="203.5" y="349.0981">Prepare</text><polygon fill="#181818" points="207.5,379.2969,197.5,383.2969,207.5,387.2969,203.5,383.2969" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="201.5" x2="333.5" y1="383.2969" y2="383.2969"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="44" x="213.5" y="378.231">Yes/No</text><polygon fill="#181818" points="356.5,408.4297,366.5,412.4297,356.5,416.4297,360.5,412.4297" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="196.5" x2="362.5" y1="412.4297" y2="412.4297"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="50" x="203.5" y="407.3638">Prepare</text><polygon fill="#181818" points="207.5,437.5625,197.5,441.5625,207.5,445.5625,203.5,441.5625" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="201.5" x2="367.5" y1="441.5625" y2="441.5625"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="44" x="213.5" y="436.4966">Yes/No</text><path d="M10,463.5625 L76,463.5625 L76,470.6953 L66,480.6953 L10,480.6953 L10,463.5625 " fill="#EEEEEE" style="stroke:#000000;stroke-width:1.5;"/><rect fill="none" height="773.125" style="stroke:#000000;stroke-width:1.5;" width="400.5" x="10" y="463.5625"/><text fill="#000000" font-family="sans-serif" font-size="13" font-weight="bold" lengthAdjust="spacing" textLength="21" x="25" y="476.6294">alt</text><text fill="#000000" font-family="sans-serif" font-size="11" font-weight="bold" lengthAdjust="spacing" textLength="125" x="91" y="475.7729">[&#25152;&#26377;&#30340;&#32467;&#26524;&#37117;&#36820;&#22238; Yes]</text><path d="M20,487.6953 L123,487.6953 L123,494.8281 L113,504.8281 L20,504.8281 L20,487.6953 " fill="#EEEEEE" style="stroke:#000000;stroke-width:1.5;"/><rect fill="none" height="356.5938" style="stroke:#000000;stroke-width:1.5;" width="380.5" x="20" y="487.6953"/><text fill="#000000" font-family="sans-serif" font-size="13" font-weight="bold" lengthAdjust="spacing" textLength="58" x="35" y="500.7622">commit</text><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="196.5" x2="238.5" y1="525.9609" y2="525.9609"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="238.5" x2="238.5" y1="525.9609" y2="538.9609"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="197.5" x2="238.5" y1="538.9609" y2="538.9609"/><polygon fill="#181818" points="207.5,534.9609,197.5,538.9609,207.5,542.9609,203.5,538.9609" style="stroke:#181818;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="90" x="203.5" y="520.895">Commit(WAL)</text><polygon fill="#181818" points="65.5,564.0938,55.5,568.0938,65.5,572.0938,61.5,568.0938" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="59.5" x2="195.5" y1="568.0938" y2="568.0938"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="118" x="71.5" y="563.0278">Response Commit</text><path d="M170,583.0938 L248,583.0938 L248,590.2266 L238,600.2266 L170,600.2266 L170,583.0938 " fill="#EEEEEE" style="stroke:#000000;stroke-width:1.5;"/><rect fill="none" height="75.3984" style="stroke:#000000;stroke-width:1.5;" width="152.5" x="170" y="583.0938"/><text fill="#000000" font-family="sans-serif" font-size="13" font-weight="bold" lengthAdjust="spacing" textLength="33" x="185" y="596.1606">loop</text><polygon fill="#181818" points="288.5,617.3594,298.5,621.3594,288.5,625.3594,292.5,621.3594" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="196.5" x2="294.5" y1="621.3594" y2="621.3594"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="51" x="203.5" y="616.2935">Commit</text><polygon fill="#181818" points="207.5,646.4922,197.5,650.4922,207.5,654.4922,203.5,650.4922" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="201.5" x2="299.5" y1="650.4922" y2="650.4922"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="23" x="213.5" y="645.4263">Ack</text><path d="M170,672.4922 L248,672.4922 L248,679.625 L238,689.625 L170,689.625 L170,672.4922 " fill="#EEEEEE" style="stroke:#000000;stroke-width:1.5;"/><rect fill="none" height="75.3984" style="stroke:#000000;stroke-width:1.5;" width="186.5" x="170" y="672.4922"/><text fill="#000000" font-family="sans-serif" font-size="13" font-weight="bold" lengthAdjust="spacing" textLength="33" x="185" y="685.5591">loop</text><polygon fill="#181818" points="322.5,706.7578,332.5,710.7578,322.5,714.7578,326.5,710.7578" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="196.5" x2="328.5" y1="710.7578" y2="710.7578"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="51" x="203.5" y="705.6919">Commit</text><polygon fill="#181818" points="207.5,735.8906,197.5,739.8906,207.5,743.8906,203.5,739.8906" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="201.5" x2="333.5" y1="739.8906" y2="739.8906"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="23" x="213.5" y="734.8247">Ack</text><path d="M170,761.8906 L248,761.8906 L248,769.0234 L238,779.0234 L170,779.0234 L170,761.8906 " fill="#EEEEEE" style="stroke:#000000;stroke-width:1.5;"/><rect fill="none" height="75.3984" style="stroke:#000000;stroke-width:1.5;" width="220.5" x="170" y="761.8906"/><text fill="#000000" font-family="sans-serif" font-size="13" font-weight="bold" lengthAdjust="spacing" textLength="33" x="185" y="774.9575">loop</text><polygon fill="#181818" points="356.5,796.1563,366.5,800.1563,356.5,804.1563,360.5,800.1563" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="196.5" x2="362.5" y1="800.1563" y2="800.1563"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="51" x="203.5" y="795.0903">Commit</text><polygon fill="#181818" points="207.5,825.2891,197.5,829.2891,207.5,833.2891,203.5,829.2891" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="201.5" x2="367.5" y1="829.2891" y2="829.2891"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="23" x="213.5" y="824.2231">Ack</text><line style="stroke:#000000;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="10" x2="410.5" y1="852.2891" y2="852.2891"/><text fill="#000000" font-family="sans-serif" font-size="11" font-weight="bold" lengthAdjust="spacing" textLength="131" x="15" y="862.4995">[&#33267;&#23569;&#26377;&#19968;&#20010;&#32467;&#26524;&#36820;&#22238; No]</text><path d="M20,873.0938 L108,873.0938 L108,880.2266 L98,890.2266 L20,890.2266 L20,873.0938 " fill="#EEEEEE" style="stroke:#000000;stroke-width:1.5;"/><rect fill="none" height="356.5938" style="stroke:#000000;stroke-width:1.5;" width="380.5" x="20" y="873.0938"/><text fill="#000000" font-family="sans-serif" font-size="13" font-weight="bold" lengthAdjust="spacing" textLength="43" x="35" y="886.1606">abort</text><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="196.5" x2="238.5" y1="911.3594" y2="911.3594"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="238.5" x2="238.5" y1="911.3594" y2="924.3594"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="197.5" x2="238.5" y1="924.3594" y2="924.3594"/><polygon fill="#181818" points="207.5,920.3594,197.5,924.3594,207.5,928.3594,203.5,924.3594" style="stroke:#181818;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="74" x="203.5" y="906.2935">Abort(WAL)</text><polygon fill="#181818" points="65.5,949.4922,55.5,953.4922,65.5,957.4922,61.5,953.4922" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="59.5" x2="195.5" y1="953.4922" y2="953.4922"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="102" x="71.5" y="948.4263">Response Abort</text><path d="M170,968.4922 L248,968.4922 L248,975.625 L238,985.625 L170,985.625 L170,968.4922 " fill="#EEEEEE" style="stroke:#000000;stroke-width:1.5;"/><rect fill="none" height="75.3984" style="stroke:#000000;stroke-width:1.5;" width="152.5" x="170" y="968.4922"/><text fill="#000000" font-family="sans-serif" font-size="13" font-weight="bold" lengthAdjust="spacing" textLength="33" x="185" y="981.5591">loop</text><polygon fill="#181818" points="288.5,1002.7578,298.5,1006.7578,288.5,1010.7578,292.5,1006.7578" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="196.5" x2="294.5" y1="1006.7578" y2="1006.7578"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="35" x="203.5" y="1001.6919">Abort</text><polygon fill="#181818" points="207.5,1031.8906,197.5,1035.8906,207.5,1039.8906,203.5,1035.8906" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="201.5" x2="299.5" y1="1035.8906" y2="1035.8906"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="23" x="213.5" y="1030.8247">Ack</text><path d="M170,1057.8906 L248,1057.8906 L248,1065.0234 L238,1075.0234 L170,1075.0234 L170,1057.8906 " fill="#EEEEEE" style="stroke:#000000;stroke-width:1.5;"/><rect fill="none" height="75.3984" style="stroke:#000000;stroke-width:1.5;" width="186.5" x="170" y="1057.8906"/><text fill="#000000" font-family="sans-serif" font-size="13" font-weight="bold" lengthAdjust="spacing" textLength="33" x="185" y="1070.9575">loop</text><polygon fill="#181818" points="322.5,1092.1563,332.5,1096.1563,322.5,1100.1563,326.5,1096.1563" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="196.5" x2="328.5" y1="1096.1563" y2="1096.1563"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="35" x="203.5" y="1091.0903">Abort</text><polygon fill="#181818" points="207.5,1121.2891,197.5,1125.2891,207.5,1129.2891,203.5,1125.2891" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="201.5" x2="333.5" y1="1125.2891" y2="1125.2891"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="23" x="213.5" y="1120.2231">Ack</text><path d="M170,1147.2891 L248,1147.2891 L248,1154.4219 L238,1164.4219 L170,1164.4219 L170,1147.2891 " fill="#EEEEEE" style="stroke:#000000;stroke-width:1.5;"/><rect fill="none" height="75.3984" style="stroke:#000000;stroke-width:1.5;" width="220.5" x="170" y="1147.2891"/><text fill="#000000" font-family="sans-serif" font-size="13" font-weight="bold" lengthAdjust="spacing" textLength="33" x="185" y="1160.356">loop</text><polygon fill="#181818" points="356.5,1181.5547,366.5,1185.5547,356.5,1189.5547,360.5,1185.5547" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="196.5" x2="362.5" y1="1185.5547" y2="1185.5547"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="35" x="203.5" y="1180.4888">Abort</text><polygon fill="#181818" points="207.5,1210.6875,197.5,1214.6875,207.5,1218.6875,203.5,1214.6875" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;stroke-dasharray:2.0,2.0;" x1="201.5" x2="367.5" y1="1214.6875" y2="1214.6875"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="23" x="213.5" y="1209.6216">Ack</text><!--SRC=[hP51IyCm68Rl_HM1NVImUlSWf3bu6JAa81vh5sfOcuGqkmyKP4VHauxz04-2bu68VsRhjdzXsjJIf6KMN2_bUxytpvTyRn1A9W2A2QRIuO6G92Gye1Buo2YXKNb6XHmd4cp20UDO18hd0FNv2FJxPm22Kn1XMPSy9QMcX6gIwxeWcSIILBnSSZ0T_SxX0glvs1uphCcmKFsSUutJamjcNw1kzlQPaML63NDnio2Me3SWqQqy5nXJaCscsNosURdVV3vbY_dkxclx_Rn-NUI72ev-IiYIXEXtrsOMT5IqZgxWuDZkwxoKvnAddD4Kb-RAf-4nOxoIh6LP1woTmN1SjVBdTUDwxLpllrpKpaNxkVaVnsetlI6XOx1z-5Y_FwfCLilfQlccOoapAHFNjmXkc6XF1EQTZe50W_9t7gR_O74qiGT9eudj4WOT_G00]--></g></svg><p>有一些关键点：</p><ul><li>一旦回复 Prepare 消息为 Yes 之后，就不能结束事务，必须等待 TC 进行协调；回复 No 之后可以直接 Abort 掉本地事务;</li><li>本地没有对应的 Abort 事务也要返回 Ack 信息。</li></ul><hr><p>参考链接:</p><ul><li><a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-824">https://mit-public-courses-cn-translatio.gitbook.io/mit6-824</a></li><li><a href="http://www.kailing.pub/raft/index.html">http://www.kailing.pub/raft/index.html</a></li><li><a href="https://sineyuan.github.io/post/etcd-raft-source-guide/">https://sineyuan.github.io/post/etcd-raft-source-guide/</a></li><li><a href="https://github.com/etcd-io/raft">https://github.com/etcd-io/raft</a></li><li><a href="https://raft.github.io/">https://raft.github.io/</a></li><li><a href="https://github.com/goraft/raft">https://github.com/goraft/raft</a></li><li><a href="https://github.com/hashicorp/raft">https://github.com/hashicorp/raft</a></li><li><a href="https://zhuanlan.zhihu.com/p/49792009">https://zhuanlan.zhihu.com/p/49792009</a></li><li><a href="http://www.zhaowenyu.com/etcd-doc/introduction/what-is-raft.html">http://www.zhaowenyu.com/etcd-doc/introduction/what-is-raft.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/91288179">https://zhuanlan.zhihu.com/p/91288179</a></li><li><a href="https://docs.qq.com/doc/DY0VxSkVGWHFYSlZJ?_t=1609557593539">https://docs.qq.com/doc/DY0VxSkVGWHFYSlZJ?_t&#x3D;1609557593539</a></li><li><a href="https://www.open-open.com/lib/view/open1328763454608.html">https://www.open-open.com/lib/view/open1328763454608.html</a></li><li><a href="https://ms2008.github.io/2019/12/04/etcd-rumor/">https://ms2008.github.io/2019/12/04/etcd-rumor/</a></li><li><a href="https://zhuanlan.zhihu.com/p/152105666">https://zhuanlan.zhihu.com/p/152105666</a></li><li><a href="https://zhuanlan.zhihu.com/p/524885008">https://zhuanlan.zhihu.com/p/524885008</a></li><li><a href="https://t1mek1ller.github.io/2018/03/01/raft/">https://t1mek1ller.github.io/2018/03/01/raft/</a></li><li><a href="https://www.jianshu.com/p/ce47091ccd5b">https://www.jianshu.com/p/ce47091ccd5b</a></li><li><a href="https://cloud.tencent.com/developer/beta/article/1833688">https://cloud.tencent.com/developer/beta/article/1833688</a></li><li><a href="https://cloud.tencent.com/developer/beta/article/1450773">https://cloud.tencent.com/developer/beta/article/1450773</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;该文档主要是 &lt;a href=&quot;https://mit-public-courses-cn-translatio.gitbook.io/mit6-824&quot;&gt;mit 6.824&lt;/a&gt; 课程的笔记以及一些扩展。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Distributed-Systems&quot;&gt;&lt;a href=&quot;#Distributed-Systems&quot; class=&quot;headerlink&quot; title=&quot;Distributed Systems&quot;&gt;&lt;/a&gt;Distributed Systems&lt;/h2&gt;&lt;h3 id=&quot;Drivens-and-Challenges&quot;&gt;&lt;a href=&quot;#Drivens-and-Challenges&quot; class=&quot;headerlink&quot; title=&quot;Drivens and Challenges&quot;&gt;&lt;/a&gt;Drivens and Challenges&lt;/h3&gt;&lt;p&gt;分布式系统的核心是通过网络来协调，共同完成一致任务的一些计算机。包括大型网站的存储系统、大数据运算(MapReduce)。&lt;em&gt;在设计一个系统时或者面对一个需要解决的问题时，如果可以在一台计算机上解决，而不需要分布式系统，那就应该用一台计算机解决问题。很多的工作都可以在一台计算机上完成，并且通常比分布式系统简单很多。所以，在选择使用分布式系统解决问题之前，应该充分尝试别的思路，因为分布式系统会让问题解决变得复杂。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;分布式系统会让问题的解决变得复杂，引入分布式系统的驱动力主要是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要获得更高的计算性能：大量的并行运算、大量 CPU、大量内存、以及大量磁盘在并行的运行；&lt;/li&gt;
&lt;li&gt;可以提供容错(tolerate faults)。比如两台计算机运行完全相同的任务，其中一台发生故障，可以切换到另外一台；&lt;/li&gt;
&lt;li&gt;有一些问题天然在空间上就是分布式的。例如银行转账，本身就分布在不同的地域，这就需要一种两者之间协调的方法，所以有一些天然的原因导致系统是物理分布的；&lt;/li&gt;
&lt;li&gt;构建分布式系统来达成一些安全的目标。比如有一些代码并不被信任，但是有需要和它进行交互，这些代码不会立即表现的恶意或者出现 Bug。你不会想要信任这些代码，所以想要将代码分散在多处运行，这样你的代码在另外一台计算机运行，我的代码在我的计算机上运行，通过一些特定的网络协议通信。所以，我们可能会担心安全问题，我们把系统分成多个的计算机，这样可以限制出错域。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Architecture" scheme="http://example.com/categories/Architecture/"/>
    
    
    <category term="Distributed" scheme="http://example.com/tags/Distributed/"/>
    
    <category term="Raft" scheme="http://example.com/tags/Raft/"/>
    
  </entry>
  
  <entry>
    <title>eBPF 原理及其应用</title>
    <link href="http://example.com/2022/12/06/eBPF/getting-start-with-eBPF/"/>
    <id>http://example.com/2022/12/06/eBPF/getting-start-with-eBPF/</id>
    <published>2022-12-06T02:08:36.000Z</published>
    <updated>2023-05-11T05:53:11.746Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>该文档主要是<a href="https://time.geekbang.org/column/intro/100104501">《eBPF 核心技术与实战》</a>课程的笔记以及一些扩展。其中代码在<a href="https://github.com/champly/ebpf-learn-code">ebpf-learn-code</a>仓库中，编译环境都在 <code>Docker</code> 镜像中，也具备 <a href="https://github.com/cilium/ebpf">cilium-ebpf</a> 的编译环境。</p></blockquote><h2 id="什么是eBPF"><a href="#什么是eBPF" class="headerlink" title="什么是eBPF"></a>什么是eBPF</h2><p><code>eBPF</code> 是从 <code>BPF</code> 技术扩展而来的，得益于 <code>BPF</code> 的设计:</p><ul><li>内核态引入一个新的虚拟机(执行引擎)，所有指令都在内核虚拟机中运行；</li><li>用户态使用 <code>BPF</code> 字节码来定义过滤表达式，然后传递给内核，由内核虚拟机解释执行。</li></ul><p>这就使得包过滤可以直接在内核中执行，避免了向用户态复制每个数据包，从而极大提升了包过滤的性能，进而被广大操作系统广泛接受。<em>而 <code>BPF</code> 最初的名字由最初的 <code>BSD Packet Filter</code> 变成了 <code>Berkeley Packet Filter</code></em> 。</p><h3 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h3><ul><li><code>BPF</code> 诞生五年后， <code>Linux</code> 2.1.75 首次引入了 <code>BPF</code> 技术;</li><li><code>Linux</code> 3.0 中增加的 <code>BPF</code> 即时编译器替换了原本性能较差的解释器，算是一个重大更新;</li><li>2014 年，为了研究新的SDN(软件定义网络)方案，第一次革命性的更新，将 <code>BPF</code> 扩展为一个通用的虚拟机，也就是 <code>eBPF</code>。不仅扩展了寄存器数量，引入了全新的 <code>BPF</code> 映射存储(Map)，还在 5.x 内核中将原本单一的数据包过滤事件逐步扩展到了内核态函数、用户态函数、跟踪点、性能事件(perf_events)以及安全控制等(转折点)。</li></ul><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><code>eBPF</code> 程序并不像常规的线程那样，启动后就一直运行在那里，它需要事件触发后才会执行。这些事件包括系统调用、内核跟踪点、内核函数和用户态函数的调用退出、网络事件等等，借助强大的内核态插桩(kprobe)和用户态插桩(uprobe)，<code>eBPF</code> 程序几乎可以在内核和应用的任意位置进行插桩。</p><blockquote><p><strong>确保安全和稳定一直都是 <code>eBPF</code> 的首要任务，不安全的 <code>eBPF</code> 程序根本就不会提交到内核虚拟机中执行。</strong></p></blockquote><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>如下图（图片来自<a href="https://www.brendangregg.com/ebpf.html">www.brendangregg.com</a>）:</p><p><img data-src="/images/eBPF/getting-start-with-eBPF/implementation-process.jpg" alt="implementation-process" title="eBPF 执行过程"></p><p>通常借助 <code>LLVM</code> 把编写的 <code>eBPF</code> 程序转换为 <code>BPF</code> 字节码，然后再通过 <code>bpf</code> 系统调用提交给内核执行。内核在接受 <code>BPF</code> 字节码之前，会首先通过验证器对字节码进行校验，只有通过校验的 <code>BPF</code> 字节码才会提交到即时编译器(JIT)执行。如果 <code>BPF</code> 字节码中包含了不安全的操作，验证器会直接拒绝 <code>BPF</code> 程序的执行：</p><ul><li>只有特权进程才可以执行 <code>bpf</code> 系统调用;</li><li><code>BPF</code> 程序不能包涵无限循环;</li><li><code>BPF</code> 程序不能导致内核崩溃;</li><li><code>BPF</code> 程序必须在有限时间内完成。</li></ul><p><code>BPF</code> 程序可以利用 <code>BPF</code> 映射进行存储，而用户态程序通常也需要通过 <code>BPF</code> 映射同运行在内核中的 <code>BPF</code> 程序进行交互。如下图(<a href="https://ebpf.io/what-is-ebpf/">ebpf.io</a>):</p><p><img data-src="/images/eBPF/getting-start-with-eBPF/verification-architecture.png" alt="verification-architecture.png"></p><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p><code>eBPF</code> 不是万能的，有很多限制：</p><ul><li><code>eBPF</code> 程序必须被验证器校验通过后才能执行，且不能包含无法到达的指令;</li><li><code>eBPF</code> 程序不能随意调用内核函数，只能调用在 <code>API</code> 中定义的辅助函数;</li><li><code>eBPF</code> 程序栈空间最多只有 512 字节，想要更大的存储，就必须要借助映射存储(Map);</li><li>在内核 5.2 之前，<code>eBPF</code> 字节码最多只支持 4096 条指令，而 5.2 内核把这个限制提高到了 100w 条;</li><li>由于内核的快速变化，在不同版本内核中运行时，需要访问内核数据结构的 <code>eBPF</code> 程序可能需要调整源码，并重写编译。</li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>作为 <code>eBPF</code> 最重大的改进之一，一次编译到处执行(CO-RE)解决了内核数据结构在不同版本差异导致的兼容性问题，不过在使用 <code>CO-RE</code> 之前，需要内核开启 <code>CONFIG_DEBUG_INFO_BTF=y</code> 和 <code>CONFIG_DEBUG_INFO=y</code> 这两个编译选项。高版本已经默认开启，否则需要重新编译内核。</p><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><p>主要包括:</p><ul><li>将 <code>eBPF</code> 程序编译成字节码的 <code>LLVM</code>;</li><li><code>C</code> 语言程序编译工具 <code>make</code>;</li><li>最流行的 <code>eBPF</code> 工具集 <code>BCC</code> 和它依赖的内核头文件;</li><li>与内核代码仓库实时同步的 <code>libbpf</code>;</li><li>同样是内核代码提供的 <code>eBPF</code> 程序管理工具 <code>bpftool</code>。</li></ul><p>可以通过下面的命令来统一安装:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">For Ubuntu20.10+</span></span><br><span class="line">sudo apt-get install -y  make clang llvm libelf-dev libbpf-dev bpfcc-tools libbpfcc-dev linux-tools-$(uname -r) linux-headers-$(uname -r)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">For RHEL8.2+</span></span><br><span class="line">sudo yum install libbpf-devel make clang llvm elfutils-libelf-devel bpftool bcc-tools bcc-devel</span><br></pre></td></tr></table></figure><p>也可以直接通过 <a href="https://github.com/champly/ebpf-learn-code">https://github.com/champly/ebpf-learn-code</a> 这个项目里面的环境来学习和测试，直接 <code>make run</code> 就可以了。</p><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><p>一般来说，<code>eBPF</code>的开发和执行过程分为以下 5 步:</p><ul><li>使用 <code>C</code> 语言开发一个 <code>eBPF</code> 程序;</li><li>借助 <code>LLVM</code> 把 <code>eBPF</code> 程序编译成 <code>BPF</code> 字节码;</li><li>通过 <code>bpf</code> 系统调用，把 <code>BPF</code> 字节码提交给内核;</li><li>内核验证并运行 <code>BPF</code> 字节码，并把相应的程序状态保存到 <code>BPF</code> 映射中;</li><li>用户程序通过 <code>BPF</code> 映射查询 <code>BPF</code> 字节码的运行状态。</li></ul><h3 id="BCC"><a href="#BCC" class="headerlink" title="BCC"></a>BCC</h3><p><code>BCC</code> 是一个 <code>BPF</code> 编译器集合，包含了用于构建 <code>BPF</code> 程序的变成框架和库，并提供了大量可以直接使用的工具。把上述的 <code>eBPF</code> 执行过程通过内置框架抽象了起来，并提供了 <code>Python</code>、<code>C++</code> 等编程语言的接口，就可以简单通过 <code>Python</code> 语言去跟 <code>eBPF</code> 的各种事件和数据进行交互。</p><p>如下这个<a href="https://github.com/champly/ebpf-learn-code/tree/main/code/session3">代码</a>:</p><figure class="highlight c"><figcaption><span>trace-open.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;uapi/linux/openat2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data_t</span> &#123;</span></span><br><span class="line">  u32 pid;</span><br><span class="line">  u64 ts;</span><br><span class="line">  <span class="type">char</span> comm[TASK_COMM_LEN];</span><br><span class="line">  <span class="type">char</span> fname[NAME_MAX];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BPF_PERF_OUTPUT(events);</span><br><span class="line"></span><br><span class="line"><span class="comment">// define kprobe function</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hello_world2</span><span class="params">(<span class="keyword">struct</span> pt_regs *ctx, <span class="type">int</span> dfd, <span class="type">const</span> <span class="type">char</span> __user *filename,</span></span><br><span class="line"><span class="params">                 <span class="keyword">struct</span> open_how *how)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">data_t</span> <span class="title">data</span> =</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get PID &amp; time</span></span><br><span class="line">  data.pid = bpf_get_current_pid_tgid();</span><br><span class="line">  data.ts = bpf_ktime_get_ns();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get program name</span></span><br><span class="line">  <span class="keyword">if</span> (bpf_get_current_comm(&amp;data.comm, <span class="keyword">sizeof</span>(data.comm)) == <span class="number">0</span>) &#123;</span><br><span class="line">    bpf_probe_read(&amp;data.fname, <span class="keyword">sizeof</span>(data.fname), (<span class="type">void</span> *)filename);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// submit event</span></span><br><span class="line">  events.perf_submit(ctx, &amp;data, <span class="keyword">sizeof</span>(data));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>trace-open.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1) load BPF program</span></span><br><span class="line">b = BPF(src_file=<span class="string">&quot;trace-open.c&quot;</span>)</span><br><span class="line">b.attach_kprobe(event=<span class="string">&quot;do_sys_openat2&quot;</span>, fn_name=<span class="string">&quot;hello_world2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2) print header</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%-18s %-16s %-6s %-16s&quot;</span> % (<span class="string">&quot;TIME(s)&quot;</span>, <span class="string">&quot;COMM&quot;</span>, <span class="string">&quot;PID&quot;</span>, <span class="string">&quot;FILE&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3) define the callback for perf event</span></span><br><span class="line">start = <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_event</span>(<span class="params">cpu, data, size</span>):</span><br><span class="line">    <span class="keyword">global</span> start</span><br><span class="line">    event = b[<span class="string">&quot;events&quot;</span>].event(data)</span><br><span class="line">    <span class="keyword">if</span> start == <span class="number">0</span>:</span><br><span class="line">        start = event.ts</span><br><span class="line">    time_s = (<span class="built_in">float</span>(event.ts - start)) / <span class="number">1000000000</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%-18.9s %-16s %-6d %16s&quot;</span> % (time_s, event.comm, event.pid, event.fname))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4) loop with callback to print_event</span></span><br><span class="line">b[<span class="string">&quot;events&quot;</span>].open_perf_buffer(print_event)</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        b.perf_buffer_poll()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        exit()</span><br></pre></td></tr></table></figure><p>打开一个终端:</p><figure class="highlight shell"><figcaption><span>Terminal1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make run</span></span><br><span class="line">sh docker-run.sh</span><br><span class="line">root@9ceb0649d5e5:/# cd ~/code/session3/</span><br><span class="line">root@9ceb0649d5e5:~/code/session3# python3 trace-open.py</span><br><span class="line">TIME(s)            COMM             PID    FILE</span><br></pre></td></tr></table></figure><p>打开另外一个终端:</p><figure class="highlight shell"><figcaption><span>Terminal2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">champly @ champlydeiMac <span class="keyword">in</span> ~ [15:40:16]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">exec</span> -it ebpf-for-mac bash</span></span><br><span class="line">root@9ceb0649d5e5:/# ls</span><br><span class="line">bin  boot  dev  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">root@9ceb0649d5e5:/#</span><br></pre></td></tr></table></figure><p>同时可以看到第一个终端有数据输出:</p><figure class="highlight shell"><figcaption><span>Terminal1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TIME(s)            COMM             PID    FILE</span><br><span class="line">0.0                b&#x27;ls&#x27;            8931   b&#x27;/etc/ld.so.cache&#x27;</span><br><span class="line">0.0006603          b&#x27;ls&#x27;            8931   b&#x27;/lib/x86_64-linux-gnu/libselinux.so.1&#x27;</span><br><span class="line">0.0007822          b&#x27;ls&#x27;            8931   b&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span><br><span class="line">0.0008942          b&#x27;ls&#x27;            8931   b&#x27;/lib/x86_64-linux-gnu/libpcre2-8.so.0&#x27;</span><br><span class="line">0.0011795          b&#x27;ls&#x27;            8931   b&#x27;/proc/filesystems&#x27;</span><br><span class="line">0.0013228          b&#x27;ls&#x27;            8931               b&#x27;.&#x27;</span><br></pre></td></tr></table></figure><p>可以在第二个终端通过 <code>bpftool</code> 来查看 <code>eBPF</code> 程序的状态:</p><figure class="highlight shell"><figcaption><span>Terminal2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">root@9ceb0649d5e5:/# bpftool prog list</span><br><span class="line">3: cgroup_device  tag 531db05b114e9af3</span><br><span class="line">loaded_at 2022-12-02T01:02:16+0000  uid 0</span><br><span class="line">xlated 512B  jited 325B  memlock 4096B</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">155: kprobe  name hello_world2  tag c3d700bdee3931e4  gpl</span><br><span class="line">loaded_at 2022-12-06T07:41:43+0000  uid 0</span><br><span class="line">xlated 528B  jited 359B  memlock 4096B  map_ids 296</span><br><span class="line">btf_id 28</span><br><span class="line">root@9ceb0649d5e5:/# bpftool map list</span><br><span class="line">17: ringbuf  name blocked_packets  flags 0x0</span><br><span class="line">key 0B  value 0B  max_entries 16777216  memlock 0B</span><br><span class="line">18: hash  name allowed_map  flags 0x0</span><br><span class="line">key 4B  value 4B  max_entries 10000  memlock 81920B</span><br><span class="line">20: lpm_trie  name allowed_trie  flags 0x1</span><br><span class="line">key 8B  value 8B  max_entries 1024  memlock 16384B</span><br><span class="line">297: perf_event_array  name events  flags 0x0</span><br><span class="line">key 4B  value 4B  max_entries 1  memlock 4096B</span><br><span class="line">root@9ceb0649d5e5:/# bpftool map dump id 297</span><br><span class="line">key:</span><br><span class="line">00 00 00 00</span><br><span class="line">value:</span><br><span class="line">Unknown error 524</span><br><span class="line">Found 0 elements</span><br><span class="line">root@9ceb0649d5e5:/# bpftool prog dump xlated id 155</span><br><span class="line">int hello_world2(struct pt_regs * ctx):</span><br><span class="line">; int hello_world2(struct pt_regs *ctx) &#123;</span><br><span class="line">   0: (bf) r6 = r1</span><br><span class="line">; int dfd = ctx-&gt;di; const char __user *filename = ctx-&gt;si; struct open_how *how = ctx-&gt;dx;</span><br><span class="line">   1: (79) r7 = *(u64 *)(r6 +104)</span><br><span class="line">   2: (b7) r1 = 0</span><br><span class="line">; struct data_t data = &#123;&#125;;</span><br><span class="line">   3: (7b) *(u64 *)(r10 -8) = r1</span><br><span class="line">   4: (7b) *(u64 *)(r10 -16) = r1</span><br><span class="line">   5: (7b) *(u64 *)(r10 -24) = r1</span><br><span class="line">   6: (7b) *(u64 *)(r10 -32) = r1</span><br><span class="line">   7: (7b) *(u64 *)(r10 -40) = r1</span><br><span class="line">   8: (7b) *(u64 *)(r10 -48) = r1</span><br><span class="line">   9: (7b) *(u64 *)(r10 -56) = r1</span><br><span class="line">  10: (7b) *(u64 *)(r10 -64) = r1</span><br><span class="line">  11: (7b) *(u64 *)(r10 -72) = r1</span><br><span class="line">  12: (7b) *(u64 *)(r10 -80) = r1</span><br><span class="line">  13: (7b) *(u64 *)(r10 -88) = r1</span><br><span class="line">  14: (7b) *(u64 *)(r10 -96) = r1</span><br><span class="line">  15: (7b) *(u64 *)(r10 -104) = r1</span><br><span class="line">  16: (7b) *(u64 *)(r10 -112) = r1</span><br><span class="line">  17: (7b) *(u64 *)(r10 -120) = r1</span><br><span class="line">  18: (7b) *(u64 *)(r10 -128) = r1</span><br><span class="line">  19: (7b) *(u64 *)(r10 -136) = r1</span><br><span class="line">  20: (7b) *(u64 *)(r10 -144) = r1</span><br><span class="line">  21: (7b) *(u64 *)(r10 -152) = r1</span><br><span class="line">  22: (7b) *(u64 *)(r10 -160) = r1</span><br><span class="line">  23: (7b) *(u64 *)(r10 -168) = r1</span><br><span class="line">  24: (7b) *(u64 *)(r10 -176) = r1</span><br><span class="line">  25: (7b) *(u64 *)(r10 -184) = r1</span><br><span class="line">  26: (7b) *(u64 *)(r10 -192) = r1</span><br><span class="line">  27: (7b) *(u64 *)(r10 -200) = r1</span><br><span class="line">  28: (7b) *(u64 *)(r10 -208) = r1</span><br><span class="line">  29: (7b) *(u64 *)(r10 -216) = r1</span><br><span class="line">  30: (7b) *(u64 *)(r10 -224) = r1</span><br><span class="line">  31: (7b) *(u64 *)(r10 -232) = r1</span><br><span class="line">  32: (7b) *(u64 *)(r10 -240) = r1</span><br><span class="line">  33: (7b) *(u64 *)(r10 -248) = r1</span><br><span class="line">  34: (7b) *(u64 *)(r10 -256) = r1</span><br><span class="line">  35: (7b) *(u64 *)(r10 -264) = r1</span><br><span class="line">  36: (7b) *(u64 *)(r10 -272) = r1</span><br><span class="line">  37: (7b) *(u64 *)(r10 -280) = r1</span><br><span class="line">  38: (7b) *(u64 *)(r10 -288) = r1</span><br><span class="line">; data.pid = bpf_get_current_pid_tgid();</span><br><span class="line">  39: (85) call bpf_unspec#0</span><br><span class="line">; data.pid = bpf_get_current_pid_tgid();</span><br><span class="line">  40: (63) *(u32 *)(r10 -288) = r0</span><br><span class="line">; data.ts = bpf_ktime_get_ns();</span><br><span class="line">  41: (85) call bpf_unspec#0</span><br><span class="line">; data.ts = bpf_ktime_get_ns();</span><br><span class="line">  42: (7b) *(u64 *)(r10 -280) = r0</span><br><span class="line">; struct data_t data = &#123;&#125;;</span><br><span class="line">  43: (bf) r1 = r10</span><br><span class="line">  44: (07) r1 += -272</span><br><span class="line">; if (bpf_get_current_comm(&amp;data.comm, sizeof(data.comm)) == 0) &#123;</span><br><span class="line">  45: (b7) r2 = 16</span><br><span class="line">  46: (85) call bpf_unspec#0</span><br><span class="line">  47: (67) r0 &lt;&lt;= 32</span><br><span class="line">  48: (77) r0 &gt;&gt;= 32</span><br><span class="line">; if (bpf_get_current_comm(&amp;data.comm, sizeof(data.comm)) == 0) &#123;</span><br><span class="line">  49: (55) if r0 != 0x0 goto pc+5</span><br><span class="line">; bpf_probe_read(&amp;data.fname, sizeof(data.fname), (void *)filename);</span><br><span class="line">  50: (bf) r1 = r10</span><br><span class="line">  51: (07) r1 += -256</span><br><span class="line">; bpf_probe_read(&amp;data.fname, sizeof(data.fname), (void *)filename);</span><br><span class="line">  52: (b7) r2 = 255</span><br><span class="line">  53: (bf) r3 = r7</span><br><span class="line">  54: (85) call bpf_unspec#0</span><br><span class="line">; bpf_perf_event_output(ctx, bpf_pseudo_fd(1, -1), CUR_CPU_IDENTIFIER, &amp;data, sizeof(data));</span><br><span class="line">  55: (18) r2 = map[id:297]</span><br><span class="line">  57: (bf) r4 = r10</span><br><span class="line">  58: (07) r4 += -288</span><br><span class="line">; bpf_perf_event_output(ctx, bpf_pseudo_fd(1, -1), CUR_CPU_IDENTIFIER, &amp;data, sizeof(data));</span><br><span class="line">  59: (bf) r1 = r6</span><br><span class="line">  60: (18) r3 = 0xffffffff</span><br><span class="line">  62: (b7) r5 = 288</span><br><span class="line">  63: (85) call bpf_unspec#0</span><br><span class="line">; return 0;</span><br><span class="line">  64: (b7) r0 = 0</span><br><span class="line">  65: (95) exit</span><br></pre></td></tr></table></figure><p>可以查看到刚运行的 <code>eBPF</code> 程序的状态和 <code>map</code> 中的值，还有 <code>eBPF</code> 程序指令，通过 <code>bpftool prog dump jited id $ID</code> 可以查看到最后经过 <code>JIT</code> 编译之后的指令(当前 <code>Docker</code> 环境不支持，如果可以支持，请告诉我)。</p><p>还可以通过 <code>strace</code> 来查看 <code>eBPF</code> 程序的执行过程:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">root@9ceb0649d5e5:~/code/session3# strace -v -f -ebpf ./hello.py</span><br><span class="line">......</span><br><span class="line">bpf(</span><br><span class="line">    BPF_PROG_LOAD, </span><br><span class="line">    &#123;</span><br><span class="line">        prog_type=BPF_PROG_TYPE_KPROBE, </span><br><span class="line">        insn_cnt=13, </span><br><span class="line">        insns=[</span><br><span class="line">            &#123;code=BPF_ALU64|BPF_K|BPF_MOV, dst_reg=BPF_REG_1, src_reg=BPF_REG_0, off=0, imm=0x21646c72&#125;, </span><br><span class="line">            &#123;code=BPF_STX|BPF_W|BPF_MEM, dst_reg=BPF_REG_10, src_reg=BPF_REG_1, off=-8, imm=0&#125;, </span><br><span class="line">            &#123;code=BPF_LD|BPF_DW|BPF_IMM, dst_reg=BPF_REG_1, src_reg=BPF_REG_0, off=0, imm=0x6c6c6548&#125;, </span><br><span class="line">            &#123;code=BPF_LD|BPF_W|BPF_IMM, dst_reg=BPF_REG_0, src_reg=BPF_REG_0, off=0, imm=0x6f57206f&#125;, </span><br><span class="line">            &#123;code=BPF_STX|BPF_DW|BPF_MEM, dst_reg=BPF_REG_10, src_reg=BPF_REG_1, off=-16, imm=0&#125;, </span><br><span class="line">            &#123;code=BPF_ALU64|BPF_K|BPF_MOV, dst_reg=BPF_REG_1, src_reg=BPF_REG_0, off=0, imm=0&#125;, </span><br><span class="line">            &#123;code=BPF_STX|BPF_B|BPF_MEM, dst_reg=BPF_REG_10, src_reg=BPF_REG_1, off=-4, imm=0&#125;, </span><br><span class="line">            &#123;code=BPF_ALU64|BPF_X|BPF_MOV, dst_reg=BPF_REG_1, src_reg=BPF_REG_10, off=0, imm=0&#125;, </span><br><span class="line">            &#123;code=BPF_ALU64|BPF_K|BPF_ADD, dst_reg=BPF_REG_1, src_reg=BPF_REG_0, off=0, imm=0xfffffff0&#125;, </span><br><span class="line">            &#123;code=BPF_ALU64|BPF_K|BPF_MOV, dst_reg=BPF_REG_2, src_reg=BPF_REG_0, off=0, imm=0xd&#125;, </span><br><span class="line">            &#123;code=BPF_JMP|BPF_K|BPF_CALL, dst_reg=BPF_REG_0, src_reg=BPF_REG_0, off=0, imm=0x6&#125;, </span><br><span class="line">            &#123;code=BPF_ALU64|BPF_K|BPF_MOV, dst_reg=BPF_REG_0, src_reg=BPF_REG_0, off=0, imm=0&#125;, </span><br><span class="line">            &#123;code=BPF_JMP|BPF_K|BPF_EXIT, dst_reg=BPF_REG_0, src_reg=BPF_REG_0, off=0, imm=0&#125;</span><br><span class="line">        ], </span><br><span class="line">        license=&quot;GPL&quot;, </span><br><span class="line">        log_level=0, </span><br><span class="line">        log_size=0, </span><br><span class="line">        log_buf=NULL, </span><br><span class="line">        kern_version=KERNEL_VERSION(5, 15, 49), </span><br><span class="line">        prog_flags=0, </span><br><span class="line">        prog_name=&quot;hello_world&quot;, </span><br><span class="line">        prog_ifindex=0, </span><br><span class="line">        expected_attach_type=BPF_CGROUP_INET_INGRESS, </span><br><span class="line">        prog_btf_fd=3, </span><br><span class="line">        func_info_rec_size=8, </span><br><span class="line">        func_info=0x55d9d310c030, </span><br><span class="line">        func_info_cnt=1, </span><br><span class="line">        line_info_rec_size=16, </span><br><span class="line">        line_info=0x55d9d30ebf10, </span><br><span class="line">        line_info_cnt=5, </span><br><span class="line">        attach_btf_id=0, </span><br><span class="line">        attach_prog_fd=0, </span><br><span class="line">        fd_array=NULL</span><br><span class="line">    &#125;, 144) = 4</span><br></pre></td></tr></table></figure><p><em>如果去掉 <code>-ebpf</code> 可以看到更多的过程。</em></p><h3 id="内核调用"><a href="#内核调用" class="headerlink" title="内核调用"></a>内核调用</h3><p>对于用户态程序来说，它们与内核交互时必须要通过系统调用来完成。而对于 <code>eBPF</code> 程序需要通过 <code>bpf</code> 系统调用 <code>man bpf</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       bpf - perform a command on an extended BPF map or program</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       #include &lt;linux/bpf.h&gt;</span><br><span class="line"></span><br><span class="line">       int bpf(int cmd, union bpf_attr *attr, unsigned int size);</span><br></pre></td></tr></table></figure><p><a href="https://elixir.bootlin.com/linux/v6.1-rc8/source/include/uapi/linux/bpf.h#L865">include&#x2F;uapi&#x2F;linux&#x2F;bpf.h</a> 可以查看支持的 <code>BPF</code> 命令。</p><h4 id="BPF-命令"><a href="#BPF-命令" class="headerlink" title="BPF 命令"></a>BPF 命令</h4><table><thead><tr><th align="center">BPF命令</th><th align="center">功能描述</th></tr></thead><tbody><tr><td align="center">BPF_MAP_CREATE</td><td align="center">创建一个 BPF 映射</td></tr><tr><td align="center">BPF_MAP_LOOKUP_ELEM<br>BPF_MAP_UPDATE_ELEM<br>BPF_MAP_DELETE_ELEM<br>BPF_MAP_LOOKUP_AND_DELETE_ELEM<br>BPF_MAP_GET_NEXT_KEY</td><td align="center">BPF 映射相关的操作命令，包括查找、更新、删除以及遍历等</td></tr><tr><td align="center">BPF_PROG_LOAD</td><td align="center">验证并加载 BPF 程序</td></tr><tr><td align="center">BPF_PROG_ATTACH</td><td align="center">把 BPF 程序挂载到内核事件上</td></tr><tr><td align="center">BPF_PROG_DETACH</td><td align="center">把 BPF 程序从内核事件上卸载</td></tr><tr><td align="center">BPF_OBJ_PIN</td><td align="center">把 BPF 程序或映射挂载到sysfs中的&#x2F;sys&#x2F;fs&#x2F;bpf目录中 （常用于保持 BPF 程序在内核中贮存）</td></tr><tr><td align="center">BPF_OBJ_GET</td><td align="center">从&#x2F;sys&#x2F;fs&#x2F;bpf目录中查找 BPF 程序 BPF_BTF_LOAD 验证并加载 BTF 信息</td></tr></tbody></table><h4 id="BPF-辅助函数"><a href="#BPF-辅助函数" class="headerlink" title="BPF 辅助函数"></a>BPF 辅助函数</h4><p>可以通过 <code>bpftool feature probe</code> 来查询当前系统支持的辅助函数列表，详细定义可以使用 <code>man bpf-helpers</code>，或者参考内核头文件 <a href="https://elixir.bootlin.com/linux/v6.1-rc8/source/include/uapi/linux/bpf.h#L1567">&#x2F;include&#x2F;uapi&#x2F;linux&#x2F;bpf.h</a>:</p><table><thead><tr><th align="center">辅助函数</th><th align="center">功能描述</th></tr></thead><tbody><tr><td align="center">bpf_trace_printk(fmt, fmt_size, …)</td><td align="center">向调试文件系统写入调试信息</td></tr><tr><td align="center">bpf_map_lookup_elem(map, key)<br>bpf_map_update_elem(map, key, value, flags)<br>bpf_map_delete_elem(map, key)</td><td align="center">BPF映射操作函数，分别是查找、更新和删除元素</td></tr><tr><td align="center">bpf_probe_read(dst, size, ptr)<br>bpf_probe_read_user(dst, size, ptr)<br>bpf_probe_read_kernel(dst, size, ptr)</td><td align="center">从内存指针中读取数据<br>从用户空间内存指针中读取数据<br>从内核空间内存指针中读取数据</td></tr><tr><td align="center">bpf_ktime_get_ns()</td><td align="center">获取系统启动以来的时长，单位纳秒</td></tr><tr><td align="center">bpf_get_current_pid_tgid()</td><td align="center">获取当前线程的TGID（高32位）和PID（低32位）</td></tr><tr><td align="center">bpf_get_current_comm(buf, size)</td><td align="center">获取当前线程的任务名称</td></tr><tr><td align="center">bpf_get_current_task()</td><td align="center">获取当前任务的task结构体</td></tr><tr><td align="center">bpf_perf_event_output(ctx, map, flags, data, size)</td><td align="center">向性能事件缓冲区中写入数据</td></tr><tr><td align="center">bpf_get_stackid(ctx, map, flags)</td><td align="center">获取内核态和用户态调用栈</td></tr></tbody></table><h4 id="BPF-映射"><a href="#BPF-映射" class="headerlink" title="BPF 映射"></a>BPF 映射</h4><p><code>BPF</code> 映射用于提供大块的键值存储，这些存储可被用户控件程序访问，进而获取 <code>ePBF</code> 程序的运行状态。<code>eBPF</code> 程序最多可以访问 64 个不同的 <code>BPF</code> 映射，并且不同的 <code>eBPF</code> 程序也可以通过相同的 <code>BPF</code> 映射来共享它们的状态。</p><p><img data-src="/images/eBPF/getting-start-with-eBPF/bpf-map.jpg" alt="bpf-map.jpg"></p><p><code>BPF</code> 映射只能通过用户态程序的系统调用来创建，内核头文件 <a href="https://elixir.bootlin.com/linux/v6.1-rc8/source/include/uapi/linux/bpf.h#L905">&#x2F;include&#x2F;uapi&#x2F;linux&#x2F;bpf.h</a> 中的 <code>bpf_map_type</code> 定义了所有支持的映射类型，也可以通过 <code>bpftool feature probe | grep map_type</code> 来查询当前系统支持哪些映射。</p><table><thead><tr><th align="center">映射类型</th><th align="center">功能描述</th></tr></thead><tbody><tr><td align="center">BPF_MAP_TYPE_HASH</td><td align="center">哈希表映射，用于保存 key&#x2F;value对</td></tr><tr><td align="center">BPF_MAP_TYPE_LRU_HASH</td><td align="center">类似于哈希表映射，但在表满的时候自动按LRU 算法删除最久未被使用的元素</td></tr><tr><td align="center">BPF_MAP_TYPE_ARRAY</td><td align="center">数组映射，用于保存固定大小的数组（注意数组元素无法删除）</td></tr><tr><td align="center">BPF_MAP_TYPE_PROG_ARRAY</td><td align="center">程序数组映射，用于保存 BPF 程序的引用，特别适合于尾调用（即调用其他 eBPF 程序)</td></tr><tr><td align="center">BPF_MAP_TYPE_PERF_EVENT_ARRAY</td><td align="center">性能事件数组映射，用于保存性能事件跟踪记录</td></tr><tr><td align="center">BPF_MAP_TYPEPERCPU_HASH<br>BPF_MAP_TYPE_PERCPU_ARRAY</td><td align="center">每个 CPU 单独维护的哈希表和数组映射</td></tr><tr><td align="center">BPF_MAP_TYPE_STACK_TRACE</td><td align="center">调用栈跟踪映射，用于存储调用栈信息</td></tr><tr><td align="center">BPF_MAP_TYPE_ARRAY_OF_MAPS<br>BPF_MAP_TYPE_HASH_OF_MAPS</td><td align="center">映射数组和映射哈希，用于保存其他映射的引用</td></tr><tr><td align="center">BPF_MAP_TYPE_CGROUP_ARRAY</td><td align="center">CGROUP 数组映射，用于存储 cgroups 引用</td></tr><tr><td align="center">BPF_MAP_TYPE_SOCKMAP</td><td align="center">套接字映射，用于存储套接字引用，特别适用于套接字重定向</td></tr></tbody></table><blockquote><p>** BPF 映射会在用户态程序关闭文件描述符的时候自动删除**，如果想在程序退出后还保留映射，需要调用 <code>BPF_OBJ_PIN</code> 命令，将映射挂载到 <code>/sys/fs/bpf</code> 中。</p></blockquote><p>通过 <code>bpftool</code> 来查看或操作映射的具体内容:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@76f664f7d01b:~/code/session3# bpftool map create /sys/fs/bpf/stats_map type hash key 2 value 2 entries 8 name stats_map</span><br><span class="line">root@76f664f7d01b:~/code/session3# bpftool map</span><br><span class="line">17: ringbuf  name blocked_packets  flags 0x0</span><br><span class="line">key 0B  value 0B  max_entries 16777216  memlock 0B</span><br><span class="line">18: hash  name allowed_map  flags 0x0</span><br><span class="line">key 4B  value 4B  max_entries 10000  memlock 81920B</span><br><span class="line">20: lpm_trie  name allowed_trie  flags 0x1</span><br><span class="line">key 8B  value 8B  max_entries 1024  memlock 16384B</span><br><span class="line">304: hash  name stats_map  flags 0x0</span><br><span class="line">key 2B  value 2B  max_entries 8  memlock 4096B</span><br><span class="line">root@76f664f7d01b:~/code/session3# bpftool map update name stats_map key 0xc1 0xc2 value 0xa1 0xa2</span><br><span class="line">root@76f664f7d01b:~/code/session3# bpftool map dump name stats_map</span><br><span class="line">key: c1 c2  value: a1 a2</span><br><span class="line">Found 1 element</span><br><span class="line">root@76f664f7d01b:~/code/session3# rm /sys/fs/bpf/stats_map</span><br><span class="line">root@76f664f7d01b:~/code/session3#</span><br></pre></td></tr></table></figure><h4 id="BPF-类型格式-BTF"><a href="#BPF-类型格式-BTF" class="headerlink" title="BPF 类型格式(BTF)"></a>BPF 类型格式(BTF)</h4><p>开发 <code>eBPF</code> 程序时最常碰到的问题：内核数据结构的定义。安装 <code>BCC</code> 工具的时候会安装 <code>linux-headers-$&#123;uname -r&#125;</code> 依赖项。因为 <code>BCC</code> 在编译的时候需要从内核头文件中找到相应的内核数据结构定义。但是编译时依赖内核头文件也会带来很多问题:</p><ul><li><code>eBPF</code> 程序开发的时候为了获得内核数据结构的定义，就需要引入一大堆的内核头文件;</li><li>内核头文件的路径和数据结构定义在不同内核版本中很可能不同。因此，在升级内核版本时，就会遇到找不到头文件和数据结构定义错误的问题;</li><li>在很多生产环境的机器中，出于安全考虑，并不允许安装内核头文件，这时就无法得到内核数据结构的定义。在程序中定义数据结构虽然可以暂时解决问题，但也很容易把使用着错误数据结构的 <code>eBPF</code> 程序带入新版本内核中运行。</li></ul><p><code>BPF</code> 类型格式(BPF Type Format,BTF) 的诞生就是为了解决这些问题。从内核 5.2 开始，只要开启了 <code>CONFIG_DEBUG_INFO_BTF</code>，在编译内核时，内核数据结构的定义就会自动内嵌在内核二进制文件 <code>vmlinux</code> 中。可以借助下面的命令把这些数据结构的定义导出到一个头文件中 <code>vmlinux.h</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bpftool btf dump file /sys/kernel/btf/vmlinux format c &gt; vmlinux.h</span><br></pre></td></tr></table></figure><p>解决了内核数据结构的定义问题，接下来就是<strong>如何让eBPF程序在升级内核之后，不需要重新编译就可以直接运行</strong>(CO-RE)，<code>eBPF</code> 的一次编译到处执行项目借助了 <code>BTF</code> 提供的调试信息，再通过下面两个步骤，使得 <code>eBPF</code> 程序可以适配不同版本的内核:</p><ul><li>通过对 <code>BPF</code> 代码中的访问偏移量进行重写，解决了不同内核版本中数据结构偏移量不同的问题;</li><li>在 <code>libbpf</code> 中预定不同内核版本中的数据结构的修改，解决了不同内核数据结构不兼容的问题。</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="跟踪类"><a href="#跟踪类" class="headerlink" title="跟踪类"></a>跟踪类</h4><p>主要用于从系统中提取跟踪信息，进而为监控、排错、性能优化等提供数据支撑:</p><table><thead><tr><th align="center">程序类型</th><th align="center">功能描述</th><th align="center">功能限制</th></tr></thead><tbody><tr><td align="center">BPF_PROG_TYPE_KPROBE</td><td align="center">用于对特定函数进行动态插桩，根据函数位置的不同，又可以分为内核态 kprobe 和用户态 uprobe</td><td align="center">内核函数和用户函数的定义属于不稳定 API，在不同内核版本中使用时，可能需要调整 eBPF 代码实现</td></tr><tr><td align="center">BPF_PROG_TYPETRACEPOINT</td><td align="center">用于内核静态跟踪点（可以 使用 perf list 命令，查询所 有的跟踪点）</td><td align="center">虽然跟踪点可以保持稳定性，但不如 KPROBE 类型 灵活，无法按需增加新的跟踪点</td></tr><tr><td align="center">BPF_PROG_TYPE_PERF_EVENT</td><td align="center">用于性能事件 (perf_events）跟踪，包括 内核调用、定时器、硬件等 各类性能数据</td><td align="center">需配合 BPF_MAP_TYPE_PERF_EVENT_ARRAY 或 BPF_MAP_TYPE_RINGBUF 类型的映射使用</td></tr><tr><td align="center">BPF_PROG_TYPE_RAW_TRACEPOINT<br>BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE</td><td align="center">用于原始跟踪点</td><td align="center">不处理参数</td></tr><tr><td align="center">BPF_PROG_TYPE_TRACING</td><td align="center">用于开启 BTF 的跟踪点 需要开启 BTF</td><td align="center"></td></tr></tbody></table><h4 id="网络类"><a href="#网络类" class="headerlink" title="网络类"></a>网络类</h4><p>主要用于对网络数据包进行过滤和处理，进而实现网络对观测、过滤、流量控制以及性能优化等各种丰富的功能。根据事件触发的位置不同，又可以分为 <code>XDP</code>(eXpress Data Path, 高速数据路径)程序、<code>TC</code>(Traffic Control, 流量控制)程序、套接字程序以及 <code>cgroup</code> 程序:</p><h5 id="XDP"><a href="#XDP" class="headerlink" title="XDP"></a>XDP</h5><p>在网络驱动程序刚刚收到数据包时触发执行。由于无需通过繁杂的内核网络协议栈，<code>XDP</code> 程序可以用来实现高性能的网络处理方案，常用于 <code>DDos</code> 防御、防火墙、4 层负载均衡等场景。根据网卡和网卡驱动是否是原生支持 <code>XDP</code> 程序，<code>XDP</code> 运行模式可以分为:</p><ul><li>通用模式：不需要网卡和网卡驱动支持，XDP 程序像常规的网络协议栈一样运行在内核中，性能相对较差，一般用于测试;</li><li>原生模式：需要网卡驱动支持，XDP 程序在网卡驱动程序的早期路径运行;</li><li>卸载模式：需要网卡固件支持 XDP 卸载，XDP 程序直接运行在网卡上，而不再需要消耗主机的 CPU 资源，具有最好的性能。</li></ul><p>不管什么模式，<code>XDP</code> 程序在处理过网络包之后，都需要根据 <code>eBPF</code> 程序执行的结果决定数据包的去处：</p><table><thead><tr><th align="center">结果码</th><th align="center">含义</th><th align="center">使用场景</th></tr></thead><tbody><tr><td align="center">XDP_DROP</td><td align="center">丢包</td><td align="center">数据包尽早丢弃可以减少 CPU 处理时间，因而常用于防火墙、DDos 防御等丢弃非法包的场景</td></tr><tr><td align="center">XDP_PASS</td><td align="center">传递到内核协议栈</td><td align="center">内核协议栈接收到网络包，按正常流程继续处理</td></tr><tr><td align="center">XDP_TX<br>XDP_REDIRECT</td><td align="center">转发数据包到同一网卡&#x2F;不同网卡</td><td align="center">数据包在 XDP 程序修改后转发到网卡中，继续按正常的内核协议栈流程处理，常用在负载均衡中</td></tr><tr><td align="center">XDP_ABORTED</td><td align="center">错误</td><td align="center">XDP 程序运行错误，数据包丢弃并记录错误行为，以便排错</td></tr></tbody></table><blockquote><p><strong>只能用于接收!</strong></p></blockquote><h5 id="TC"><a href="#TC" class="headerlink" title="TC"></a>TC</h5><p>定义为 <code>BPF_PROG_TYPE_SCHED_CLS</code> 和 <code>BPF_PROG_TYPE_SCHED_ACT</code>，分别作为 Linux 流量控制的分类器和执行器。得益于内核 4.4 引入的 <code>direct-action</code> 模式，<code>TC</code> 程序可以直接在一个程序内完成分类和执行的动作，无需再调用其他的 <code>TC</code> 排队规则和分类器。</p><p>同 <code>XDP</code> 程序相比，<code>TC</code> 程序可以直接获取内核解析后的网络报文数据结构 <code>sk_buff</code> (<code>XDP</code> 是 <code>xdp_buff</code>)，并且可以在<strong>网卡的接收和发送两个方向上执行</strong>:</p><ul><li>对于接收网络包，TC 程序在网卡接收(GRO)之后、协议栈处理(包括 IP 层处理和 iptables 等)之前执行;</li><li>对于发送的网络包，TC 程序在协议处理（包括 IP 层处理和 iptables 等）之后、数据包发送到网卡队列(GSO)之前执行。</li></ul><p><img data-src="/images/eBPF/getting-start-with-eBPF/tc-process.jpg" alt="tc-process.jpg"></p><h5 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h5><p>用于过滤、观测或重定向套接字网络包，根据类型的不同，可以挂载到套接字(socket)、控制组(cgroup)以及网络命名空间(netns)等各个位置:</p><table><thead><tr><th align="center">套接字程序类型</th><th align="center">应用场景</th><th align="center">挂载方法</th></tr></thead><tbody><tr><td align="center">BPF_PROG_TYPE_SOCKET_FILTER</td><td align="center">用于套接字过滤和观测</td><td align="center">用户态程序可通过系统调用 setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF,…），绑定 BPF 程序到具体的 socket 上</td></tr><tr><td align="center">BPF_PROG_TYPE_SOCKOPS</td><td align="center">用于套接字修改或重定向</td><td align="center">用户态程序可通过 BPF 系统调用的 BPF_PROG_ATTACH 命令（指定挂载类型为 BPF_CGROUP_SOCK_OPS)，将其挂载到 cgroup 上</td></tr><tr><td align="center">BPF_PROG_TYPE_SKSKB</td><td align="center">用于套接字修改或消息流动态解析</td><td align="center">用户态程序可通过 BPF 系统调用的 BPF_PROG_ATTACH 命令（指定挂载类型为 BPF_SK_SKB_STREAM_VERDICT 或 BPF_SK_SKB_STREAM_PARSER)，将其挂载到 BPF_MAP_TYPE_SOCKMAP 类型的 BPF 映射上</td></tr><tr><td align="center">BPF_PROG_TYPESKMSG</td><td align="center">用于控制内核是否发送消息到套接字</td><td align="center">用户态程序可通过 BPF 系统调用的 BPF_PROG_ATTACH 命令（指定挂载类型为 BPF_SK_MSG_VERDICT) 将其挂载到 BPF_MAP_TYPE_SOCKMAP 类型的 BPF 映射上</td></tr><tr><td align="center">BPF_PROG_TYPE_SK_REUSEPORT</td><td align="center">用于控制端口是否重用</td><td align="center">用户态程序可通过系统调用 setsockopt(sock, SOL_SOCKET, SO_ATTACH_REUSEPORT_EBPF, …），绑定 BPF 程序到具体的 socket 上</td></tr><tr><td align="center">BPF_PROG_TYPE_SK_LOOKUP</td><td align="center">用于为新的 TCP 连接选择监听套接字，或为 UDP 数据包选择未连接的套接字，可用来绕过 bind 系统调用的限制</td><td align="center">用户态程序可通过系统调用 bpf(BPF_LINK_CREATE,.，绑定 BPF 程序到网 络命名空间 (netns)上</td></tr></tbody></table><h5 id="cgroup"><a href="#cgroup" class="headerlink" title="cgroup"></a>cgroup</h5><p>用于对 cgroup 内所有进程的网络过滤、套接字选项以及转发等进行动态控制，最典型的应用场景是对容器中运行的多个进程进行网络控制:</p><table><thead><tr><th align="center">cgroup 程序类型</th><th align="center">应用场景</th></tr></thead><tbody><tr><td align="center">BPF_PROG_TYPECGROUP_SKB</td><td align="center">在入口和出口过滤数据包，并可以接受或拒绝数据包</td></tr><tr><td align="center">BPF_PROG_TYPE_CGROUP_SOCK</td><td align="center">在套接字创建、释放和绑定地址时，接受或拒绝操作，也可用来统计套接字信息</td></tr><tr><td align="center">BPF_PROG_TYPE_CGROUP_SOCKOPT</td><td align="center">在 setsockopt 和 getsockopt 操作中修改套接字选项</td></tr><tr><td align="center">BPF_PROG_TYPE_CGROUP_SOCKADDR</td><td align="center">在 connect、 bind、 sendto 和 recvmsg 操作中，修改 IP 地址和端口</td></tr><tr><td align="center">BPF_PROG_TYPE_CGROUP_DEVICE</td><td align="center">对设备文件的访问进行过滤</td></tr><tr><td align="center">BPF_PROG_TYPE_CGROUP_SYSCTL</td><td align="center">对 sysctl 的访问进行过滤</td></tr></tbody></table><h4 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h4><table><thead><tr><th align="center">BPF程序类型</th><th align="center">应用场景</th></tr></thead><tbody><tr><td align="center">BPF PROG_TYPE_LSM</td><td align="center">用于 Linux 安全模块(Linux Security Module,LSM）访问控制和审计策略</td></tr><tr><td align="center">BPF_PROG_TYPE_LWT_IN<br>BPF_PROG_TYPE_LWT_OUT<br>BPF_PROG_TYPE_LWT_XMIT</td><td align="center">用于轻量级隧道（如 vxlan、 mpls 等）的封装或解封装</td></tr><tr><td align="center">BPF_PROG_TYPE_LIRC_MODE2</td><td align="center">用于红外设备的远程遥控</td></tr><tr><td align="center">BPF_PROG_TYPE_STRUCT_OPS</td><td align="center">用于修改内核结构体，目前仅支持拥塞控制算法 tcp_congestion_ops</td></tr><tr><td align="center">BPF_PROG_TYPE_FLOW_DISSECTOR</td><td align="center">用于内核流量解析器 (Flow Dissector)</td></tr><tr><td align="center">BPF_PROG_TYPE_EXT</td><td align="center">用于扩展BPF程序</td></tr></tbody></table><h3 id="bpftrace"><a href="#bpftrace" class="headerlink" title="bpftrace"></a>bpftrace</h3><p><code>bpftrace</code> 在 <code>eBPF</code> 和 <code>BCC</code> 之上构建了一个简化的跟踪语言，通过简单的几行脚本，就可以实现复杂的追踪功能。<a href="https://github.com/iovisor/bpftrace/blob/master/docs/internals_development.md">如下图</a> 所示, <code>bpftrace</code> 会把开发的脚本借助 <code>BCC</code> 编译加载到内核中执行，再通过 <code>BPF</code> 映射获取执行结果:</p><p><img data-src="/images/eBPF/getting-start-with-eBPF/bpftrace-internals.png" alt="bpftrace-internals.png"></p><p>通过 <code>bpftrace -l</code> 可以查询内核插桩和跟踪点 <code>-v</code> 可以查看函数的入口参数和返回值。</p><blockquote><p><strong>在内核插桩和跟踪点两者都可以用的情况下，应该选择更稳定的跟踪点，以保证 eBPF 程序的可移植性(即在不同的内核中都可以正常执行)。</strong></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@f287ed60a8b5:/# bpftrace -lv &#x27;tracepoint:syscalls:sys_enter_execve&#x27;</span><br><span class="line">tracepoint:syscalls:sys_enter_execve</span><br><span class="line">    int __syscall_nr</span><br><span class="line">    const char __attribute__((user)) * filename</span><br><span class="line">    const char __attribute__((user)) *const __attribute__((user)) * argv</span><br><span class="line">    const char __attribute__((user)) *const __attribute__((user)) * envp</span><br><span class="line">root@f287ed60a8b5:/# bpftrace -lv &#x27;tracepoint:syscalls:sys_exit_execve&#x27;</span><br><span class="line">tracepoint:syscalls:sys_exit_execve</span><br><span class="line">    int __syscall_nr</span><br><span class="line">    long ret</span><br><span class="line">root@f287ed60a8b5:/# bpftrace -lv &#x27;tracepoint:syscalls:sys_enter_execveat&#x27;</span><br><span class="line">tracepoint:syscalls:sys_enter_execveat</span><br><span class="line">    int __syscall_nr</span><br><span class="line">    int fd</span><br><span class="line">    const char __attribute__((user)) * filename</span><br><span class="line">    const char __attribute__((user)) *const __attribute__((user)) * argv</span><br><span class="line">    const char __attribute__((user)) *const __attribute__((user)) * envp</span><br><span class="line">    int flags</span><br><span class="line">root@f287ed60a8b5:/# bpftrace -lv &#x27;tracepoint:syscalls:sys_exit_execveat&#x27;</span><br><span class="line">tracepoint:syscalls:sys_exit_execveat</span><br><span class="line">    int __syscall_nr</span><br><span class="line">    long ret</span><br></pre></td></tr></table></figure><p>通过这个<a href="https://github.com/champly/ebpf-learn-code/blob/main/code/session7/bpftrace/sys_enter.bt">代码</a>可以达到上面的 <code>BCC</code> 事例的效果:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@f287ed60a8b5:~/code/session7/bpftrace# bpftrace sys_enter.bt</span><br><span class="line">Attaching 2 probes...</span><br><span class="line">14:37:54  1785   0      bash            bpftool prog list</span><br></pre></td></tr></table></figure><h4 id="查询用户程序跟踪点"><a href="#查询用户程序跟踪点" class="headerlink" title="查询用户程序跟踪点"></a>查询用户程序跟踪点</h4><p>可以通过 <code>readelf</code> 查询二进制文件的基本信息，使用<a href="https://github.com/champly/ebpf-learn-code/blob/main/code/session9/main.go">这个</a> <code>Go</code> 语言项目来示范:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math/rand&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rand.Seed(<span class="type">int64</span>(time.Now().Nanosecond()))</span><br><span class="line">i := rand.Intn(<span class="number">10</span>)</span><br><span class="line">a := callbackTP(i)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">callbackTP</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> i &lt; <span class="number">5</span> &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> a := <span class="number">0</span>; a &lt; i; a++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;xxxxx %d&quot;</span>, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">99</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在上面的容器环境中调试，<code>cd /root/code/session9 &amp;&amp; go build main.go</code> 进行编译，然后通过 <code>readelf</code> 查看对应的信息:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询符号表</span></span><br><span class="line">root@76f664f7d01b:~/code/session9# readelf -Ws ./main</span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 2136 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS go.go</span><br><span class="line">     2: 0000000000401000     0 FUNC    LOCAL  DEFAULT    1 runtime.text</span><br><span class="line">     3: 0000000000402140   557 FUNC    LOCAL  DEFAULT    1 cmpbody</span><br><span class="line">     4: 00000000004023a0   318 FUNC    LOCAL  DEFAULT    1 memeqbody</span><br><span class="line">     5: 0000000000402520   279 FUNC    LOCAL  DEFAULT    1 indexbytebody</span><br><span class="line">     6: 0000000000459f60    64 FUNC    LOCAL  DEFAULT    1 gogo</span><br><span class="line">     7: 0000000000459fa0    53 FUNC    LOCAL  DEFAULT    1 callRet</span><br><span class="line">     8: 0000000000459fe0    47 FUNC    LOCAL  DEFAULT    1 gosave_systemstack_switch</span><br><span class="line">     9: 000000000045a020    13 FUNC    LOCAL  DEFAULT    1 setg_gcc</span><br><span class="line">    10: 000000000045a040  1370 FUNC    LOCAL  DEFAULT    1 aeshashbody</span><br><span class="line">    11: 000000000045a5a0    75 FUNC    LOCAL  DEFAULT    1 debugCall32</span><br><span class="line">......</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询USDT信息（USDT信息位于ELF文件的notes段）</span></span><br><span class="line">root@76f664f7d01b:~/code/session9# readelf -n ./main</span><br><span class="line"></span><br><span class="line">Displaying notes found in: .note.go.buildid</span><br><span class="line">  Owner                Data size Description</span><br><span class="line">  Go                   0x00000053GO BUILDID</span><br><span class="line">   description data: 4e 6d 53 72 46 41 6d 53 44 30 6a 69 5a 6e 73 51 55 5a 74 55 2f 45 56 77 62 5a 5a 33 31 33 35 59 4f 76 5f 51 75 30 70 5a 61 2f 43 46 50 62 66 2d 67 78 4a 39 74 31 61 69 78 53 51 4b 57 32 2f 33 76 67 6b 73 51 37 38 5a 4f 73 7a 4c 5a 33 6e 41 4d 4d 52</span><br></pre></td></tr></table></figure><p>也可以通过 <code>bpftrace</code> 来查看:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询 uprobe</span></span><br><span class="line">root@76f664f7d01b:~/code/session9# bpftrace -l &quot;uprobe:./main:*&quot;</span><br><span class="line">uprobe:./main:_rt0_amd64</span><br><span class="line">uprobe:./main:_rt0_amd64_linux</span><br><span class="line">uprobe:./main:aeshashbody</span><br><span class="line">uprobe:./main:callRet</span><br><span class="line">uprobe:./main:cmpbody</span><br><span class="line">uprobe:./main:debugCall1024</span><br><span class="line">uprobe:./main:debugCall128</span><br><span class="line">uprobe:./main:debugCall16384</span><br><span class="line">uprobe:./main:debugCall2048</span><br><span class="line">uprobe:./main:debugCall256</span><br><span class="line">uprobe:./main:debugCall32</span><br><span class="line">uprobe:./main:debugCall32768</span><br><span class="line">uprobe:./main:debugCall4096</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询 usdt，这里的 Go 项目没有，通过 /usr/lib/x86_64-linux-gnu/libc.so.6 来替换</span></span><br><span class="line">root@76f664f7d01b:~/code/session9# bpftrace -l &#x27;usdt:/usr/lib/x86_64-linux-gnu/libc.so.6:*&#x27;</span><br><span class="line">usdt:/usr/lib/x86_64-linux-gnu/libc.so.6:libc:cond_broadcast</span><br><span class="line">usdt:/usr/lib/x86_64-linux-gnu/libc.so.6:libc:cond_destroy</span><br><span class="line">usdt:/usr/lib/x86_64-linux-gnu/libc.so.6:libc:cond_init</span><br><span class="line">usdt:/usr/lib/x86_64-linux-gnu/libc.so.6:libc:cond_signal</span><br><span class="line">usdt:/usr/lib/x86_64-linux-gnu/libc.so.6:libc:cond_wait</span><br><span class="line">usdt:/usr/lib/x86_64-linux-gnu/libc.so.6:libc:lll_lock_wait</span><br><span class="line">usdt:/usr/lib/x86_64-linux-gnu/libc.so.6:libc:lll_lock_wait_private</span><br><span class="line">usdt:/usr/lib/x86_64-linux-gnu/libc.so.6:libc:longjmp</span><br><span class="line">usdt:/usr/lib/x86_64-linux-gnu/libc.so.6:libc:longjmp_target</span><br><span class="line">usdt:/usr/lib/x86_64-linux-gnu/libc.so.6:libc:memory_arena_new</span><br></pre></td></tr></table></figure><blockquote><p><strong>想要通过二进制文件查询符号表和参数定义，必须在编译的时候保留 DWARF 调试信息。</strong></p></blockquote><h4 id="跟踪-Go-程序的执行"><a href="#跟踪-Go-程序的执行" class="headerlink" title="跟踪 Go 程序的执行"></a>跟踪 Go 程序的执行</h4><figure class="highlight shell"><figcaption><span>Terminal1:</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@76f664f7d01b:~/code/session9# bpftrace -e &#x27;</span><br><span class="line">        uprobe:./main:main.callbackTP &#123; printf(&quot;main.callbackTP i: %d =&gt; &quot;, reg(&quot;ax&quot;)) &#125;</span><br><span class="line">        uretprobe:./main:main.callbackTP &#123; printf(&quot;return %d\n&quot;, retval) &#125;</span><br><span class="line">&#x27;</span><br><span class="line">Attaching 2 probes...</span><br><span class="line">main.callbackTP i: 0 =&gt; return 0</span><br><span class="line">main.callbackTP i: 2 =&gt; return 2</span><br><span class="line">main.callbackTP i: 8 =&gt; return 99</span><br><span class="line">main.callbackTP i: 6 =&gt; return 99</span><br></pre></td></tr></table></figure><figure class="highlight shell"><figcaption><span>Terminal2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">champly @ champlydeiMac <span class="keyword">in</span> ~ [10:55:20]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">exec</span> -it ebpf-for-mac bash</span></span><br><span class="line">root@76f664f7d01b:/# cd /root/code/session9</span><br><span class="line">root@76f664f7d01b:~/code/session9# ./main</span><br><span class="line">0</span><br><span class="line">root@76f664f7d01b:~/code/session9# ./main</span><br><span class="line">2</span><br><span class="line">root@76f664f7d01b:~/code/session9# ./main</span><br><span class="line">xxxxx 0xxxxx 1xxxxx 2xxxxx 3xxxxx 4xxxxx 5xxxxx 6xxxxx 799</span><br><span class="line">root@76f664f7d01b:~/code/session9# ./main</span><br><span class="line">xxxxx 0xxxxx 1xxxxx 2xxxxx 3xxxxx 4xxxxx 599</span><br></pre></td></tr></table></figure><p>可以看到可以查询到 <code>callbackTP</code> 函数调用的入参和返回值。</p><h3 id="libbpf"><a href="#libbpf" class="headerlink" title="libbpf"></a>libbpf</h3><p>通过这个 <code>libbpf</code> <a href="https://github.com/champly/ebpf-learn-code/tree/main/code/session8/libbpf">代码</a> 可以实现对应 <code>BCC</code> <a href="https://github.com/champly/ebpf-learn-code/tree/main/code/session8/bcc">代码</a> 相同的功能，<em>通过 <code>libbpf</code> 代码编译的结果不能在上面提到的容器环境中运行，可以把编译的二进制文件拷贝到对应的虚拟机中直接运行</em>。</p><p>这个项目也可以使用 <code>cilium</code> 的 <a href="https://github.com/cilium/ebpf">ebpf</a> 库，通过 <code>Go</code> 语言进行开发用户态程序，这个是可以直接在容器环境中编译的。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>bpftrace 通常用在快速排查和定位系统上，它支持用单行脚本的方式来快速开发并执行一个 eBPF 程序。不过功能有限，不支持特别复杂的 eBPF 程序;</li><li>BCC 通常在开发复杂的 eBPF 程序中，其内置的各种小工具也是目前应用最为广泛的 eBPF 小程序。不过需要依赖 LLVM 和内核头文件才可以动态编译和加载 eBPF 程序;</li><li>libbpf 是从内核中抽离出来的标准库，用它开发的 eBPF 程序可以直接分发执行，这样就不需要每台机器都安装 LLVM 和内核头文件了。不过要求内核开启 BTF 特性。</li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="网络跟踪"><a href="#网络跟踪" class="headerlink" title="网络跟踪"></a>网络跟踪</h3><p>如果不知道怎么跟踪哪个函数调用，可以把所有的跟踪点都打印出来，下面的事例需要在虚拟机中实验，要不然打印不了调用栈:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">champly@ubuntu:~$ sudo bpftrace -e &#x27;tracepoint:net:* &#123; printf(&quot;%s(%d): %s %s\n&quot;, comm, pid, probe, kstack()); &#125;&#x27;</span><br><span class="line">Attaching 18 probes...</span><br><span class="line">swapper/5(0): tracepoint:net:napi_gro_receive_entry</span><br><span class="line">        napi_gro_receive+207</span><br><span class="line">        napi_gro_receive+207</span><br><span class="line">        e1000_clean_rx_irq+443</span><br><span class="line">        e1000_clean+621</span><br><span class="line">        __napi_poll+49</span><br><span class="line">        net_rx_action+575</span><br><span class="line">        __softirqentry_text_start+207</span><br><span class="line">        irq_exit_rcu+164</span><br><span class="line">        common_interrupt+138</span><br><span class="line">        asm_common_interrupt+30</span><br><span class="line">        native_safe_halt+14</span><br><span class="line">        acpi_idle_enter+91</span><br><span class="line">        cpuidle_enter_state+141</span><br><span class="line">        cpuidle_enter+46</span><br><span class="line">        call_cpuidle+35</span><br><span class="line">        do_idle+486</span><br><span class="line">        cpu_startup_entry+32</span><br><span class="line">        start_secondary+287</span><br><span class="line">        secondary_startup_64_no_verify+194</span><br></pre></td></tr></table></figure><p>如果需要排查丢包的问题，可以查询<a href="https://www.kernel.org/doc/htmldocs/networking/ch01s02.html">内核 SKB 文档</a>，可以看到内核释放 <code>SKB</code> 有两个地方:</p><ul><li><a href="https://www.kernel.org/doc/htmldocs/networking/API-kfree-skb.html">kfree_skb</a>：经常在网络异常丢包时调用;</li><li><a href="https://www.kernel.org/doc/htmldocs/networking/API-consume-skb.html">consume_skb</a>：在正常网络连接完成的时候调用。</li></ul><p>以下是访问 <code>google.com</code> 获取到的结果:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">champly@ubuntu:~$ sudo bpftrace -e &#x27;kprobe:kfree_skb /comm==&quot;curl&quot;/ &#123;printf(&quot;kstack: %s\n&quot;, kstack);&#125;&#x27;</span><br><span class="line">Attaching 1 probe...</span><br><span class="line">kstack:</span><br><span class="line">        kfree_skb+1</span><br><span class="line">        udpv6_destroy_sock+57</span><br><span class="line">        sk_common_release+34</span><br><span class="line">        udp_lib_close+9</span><br><span class="line">        inet_release+75</span><br><span class="line">        inet6_release+49</span><br><span class="line">        __sock_release+66</span><br><span class="line">        sock_close+21</span><br><span class="line">        __fput+159</span><br><span class="line">        ____fput+14</span><br><span class="line">        task_work_run+112</span><br><span class="line">        exit_to_user_mode_prepare+437</span><br><span class="line">        syscall_exit_to_user_mode+39</span><br><span class="line">        do_syscall_64+110</span><br><span class="line">        entry_SYSCALL_64_after_hwframe+68</span><br><span class="line"></span><br><span class="line">kstack:</span><br><span class="line">        kfree_skb+1</span><br><span class="line">        udpv6_destroy_sock+57</span><br><span class="line">        sk_common_release+34</span><br><span class="line">        udp_lib_close+9</span><br><span class="line">        inet_release+75</span><br><span class="line">        inet6_release+49</span><br><span class="line">        __sock_release+66</span><br><span class="line">        sock_close+21</span><br><span class="line">        __fput+159</span><br><span class="line">        ____fput+14</span><br><span class="line">        task_work_run+112</span><br><span class="line">        exit_to_user_mode_prepare+437</span><br><span class="line">        syscall_exit_to_user_mode+39</span><br><span class="line">        do_syscall_64+110</span><br><span class="line">        entry_SYSCALL_64_after_hwframe+68</span><br><span class="line"></span><br><span class="line">kstack:</span><br><span class="line">        kfree_skb+1</span><br><span class="line">        unix_release+29</span><br><span class="line">        __sock_release+66</span><br><span class="line">        sock_close+21</span><br><span class="line">        __fput+159</span><br><span class="line">        ____fput+14</span><br><span class="line">        task_work_run+112</span><br><span class="line">        exit_to_user_mode_prepare+437</span><br><span class="line">        syscall_exit_to_user_mode+39</span><br><span class="line">        do_syscall_64+110</span><br><span class="line">        entry_SYSCALL_64_after_hwframe+68</span><br><span class="line"></span><br><span class="line">kstack:</span><br><span class="line">        kfree_skb+1</span><br><span class="line">        __sys_connect_file+95</span><br><span class="line">        __sys_connect+160</span><br><span class="line">        __x64_sys_connect+26</span><br><span class="line">        do_syscall_64+97</span><br><span class="line">        entry_SYSCALL_64_after_hwframe+68</span><br><span class="line"></span><br><span class="line">kstack:</span><br><span class="line">        kfree_skb+1</span><br><span class="line">        __sys_connect_file+95</span><br><span class="line">        __sys_connect+160</span><br><span class="line">        __x64_sys_connect+26</span><br><span class="line">        do_syscall_64+97</span><br><span class="line">        entry_SYSCALL_64_after_hwframe+68</span><br></pre></td></tr></table></figure><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>通过虚拟机环境的不同 <code>Docker</code> 容器来完成相关的步骤，具体的架构如下所示:</p><pre><code class="highlight mermaid">flowchartclient[Client: wrk] --&gt; LB[LB:172.17.0.4]LB --&gt; http1[HTTP1:172.17.0.2]LB --&gt; http2[HTTP2:172.17.0.3]</code></pre><h4 id="套接字优化"><a href="#套接字优化" class="headerlink" title="套接字优化"></a>套接字优化</h4><p><code>eBPF</code> 程序: <a href="https://github.com/champly/ebpf-learn-code/blob/main/code/session12/sockops.bpf.c">sockops.bpf.c</a>、<a href="https://github.com/champly/ebpf-learn-code/blob/main/code/session12/sockredir.bpf.c">sockredir.bpf.c</a>、<a href="https://github.com/champly/ebpf-learn-code/blob/main/code/session12/sockops.h">sockops.h</a></p><p>具体实验步骤:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">champly@ubuntu:~/eBPF/example/session12$ docker run -itd --rm --name=http1 --hostname=http1 feisky/webserver</span><br><span class="line">33fb44488527c70424ff55793fdfc34d9004cde1e177b85a6e480f65dff04f2e</span><br><span class="line">champly@ubuntu:~/eBPF/example/session12$ docker run -itd --rm --name=http2 --hostname=http2 feisky/webserver</span><br><span class="line">d6428353fd79c21446923f7c50f74dc35e9f9b6de60adefe372d9004f490e9b3</span><br><span class="line">champly@ubuntu:~/eBPF/example/session12$ docker run -itd --rm --name=nginx nginx</span><br><span class="line">ed5f0acc0f9b74f5767164ef97c9826eca1586049230a2a8d50179ec6e492702</span><br><span class="line">champly@ubuntu:~/eBPF/example/session12$ IP1=$(docker inspect http1 -f &#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;)</span><br><span class="line">champly@ubuntu:~/eBPF/example/session12$ IP2=$(docker inspect http2 -f &#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;)</span><br><span class="line">champly@ubuntu:~/eBPF/example/session12$ echo &quot;Webserver1&#x27;s IP: $IP1&quot;</span><br><span class="line">Webserver1&#x27;s IP: 172.17.0.2</span><br><span class="line">champly@ubuntu:~/eBPF/example/session12$ echo &quot;Webserver2&#x27;s IP: $IP2&quot;</span><br><span class="line">Webserver2&#x27;s IP: 172.17.0.3</span><br><span class="line">champly@ubuntu:~/eBPF/example/session12$ cat&gt;nginx.conf &lt;&lt;EOF</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">user  nginx;</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">worker_processes  auto;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">&gt; error_log  /var/log/nginx/error.log notice;</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">pid        /var/run/nginx.pid;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">&gt; events &#123;</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">    worker_connections  1024;</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">&#125;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">&gt; http &#123;</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">   include       /etc/nginx/mime.types;</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">   default_type  application/octet-stream;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">&gt;     upstream webservers &#123;</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">        server <span class="variable">$IP1</span>;</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">        server <span class="variable">$IP2</span>;</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">    &#125;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">&gt;     server &#123;</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">        listen 80;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">&gt;         location / &#123;</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">            proxy_pass http://webservers;</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">        &#125;</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">    &#125;</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">&#125;</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">EOF</span></span><br><span class="line">champly@ubuntu:~/eBPF/example/session12$ docker cp nginx.conf nginx:/etc/nginx/nginx.conf</span><br><span class="line">champly@ubuntu:~/eBPF/example/session12$ docker exec nginx nginx -s reload</span><br><span class="line">2022/12/05 09:04:56 [notice] 37#37: signal process started</span><br><span class="line">champly@ubuntu:~/eBPF/example/session12$ IP_LB=$(docker inspect nginx -f &#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;)</span><br><span class="line">champly@ubuntu:~/eBPF/example/session12$ docker run -it --rm --name=client skandyla/wrk -c100 http://$IP_LB</span><br><span class="line">Running 10s test @ http://172.17.0.4</span><br><span class="line">  2 threads and 100 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     8.26ms    6.08ms  60.22ms   72.11%</span><br><span class="line">    Req/Sec     6.53k     0.92k    8.69k    68.00%</span><br><span class="line">  130064 requests in 10.02s, 20.47MB read</span><br><span class="line">Requests/sec:  12979.12</span><br><span class="line">Transfer/sec:      2.04MB</span><br><span class="line">champly@ubuntu:~/eBPF/example/session12$ sudo bpftool prog load sockops.bpf.o /sys/fs/bpf/sockops type sockops pinmaps /sys/fs/bpf</span><br><span class="line">champly@ubuntu:~/eBPF/example/session12$ sudo bpftool prog load sockredir.bpf.o /sys/fs/bpf/sockredir type sk_msg map name sock_ops_map pinned /sys/fs/bpf/sock_ops_map</span><br><span class="line">champly@ubuntu:~/eBPF/example/session12$ sudo bpftool cgroup attach /sys/fs/cgroup/unified sock_ops pinned /sys/fs/bpf/sockops</span><br><span class="line">champly@ubuntu:~/eBPF/example/session12$ sudo bpftool prog attach pinned /sys/fs/bpf/sockredir msg_verdict pinned /sys/fs/bpf/sock_ops_map</span><br><span class="line">champly@ubuntu:~/eBPF/example/session12$ docker run -it --rm --name=client skandyla/wrk -c100 http://$IP_LB</span><br><span class="line">Running 10s test @ http://172.17.0.4</span><br><span class="line">  2 threads and 100 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     7.84ms    5.76ms  54.50ms   71.07%</span><br><span class="line">    Req/Sec     6.89k     0.87k    8.97k    63.50%</span><br><span class="line">  137069 requests in 10.02s, 21.57MB read</span><br><span class="line">Requests/sec:  13676.41</span><br><span class="line">Transfer/sec:      2.15MB</span><br><span class="line">champly@ubuntu:~/eBPF/example/session12$ sudo bpftool prog detach pinned /sys/fs/bpf/sockredir msg_verdict pinned /sys/fs/bpf/sock_ops_map</span><br><span class="line">champly@ubuntu:~/eBPF/example/session12$ sudo bpftool cgroup detach /sys/fs/cgroup/unified sock_ops name bpf_sockmap</span><br><span class="line">champly@ubuntu:~/eBPF/example/session12$ sudo rm -rf /sys/fs/bpf/sockops /sys/fs/bpf/sockredir /sys/fs/bpf/sock_ops_map</span><br><span class="line">champly@ubuntu:~/eBPF/example/session12$ docker run -it --rm --name=client skandyla/wrk -c100 http://$IP_LB</span><br><span class="line">Running 10s test @ http://172.17.0.4</span><br><span class="line">  2 threads and 100 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     8.29ms    6.15ms  50.12ms   70.69%</span><br><span class="line">    Req/Sec     6.52k     0.93k    8.50k    64.00%</span><br><span class="line">  129810 requests in 10.03s, 20.43MB read</span><br><span class="line">Requests/sec:  12948.24</span><br><span class="line">Transfer/sec:      2.04MB</span><br><span class="line">champly@ubuntu:~/eBPF/example/session12$</span><br></pre></td></tr></table></figure><h4 id="XDP优化"><a href="#XDP优化" class="headerlink" title="XDP优化"></a>XDP优化</h4><p>就不要 <code>LB</code> 里面的 <code>Nginx</code> 服务，直接使用 <code>XDP</code> 程序完成转发，具体的实验代码在 <a href="https://github.com/champly/ebpf-learn-code/tree/main/code/session13">session13</a>。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">container:</span></span><br><span class="line">docker run -itd --name=lb --privileged -v /sys/kernel/debug:/sys/kernel/debug alpine</span><br><span class="line"></span><br><span class="line"><span class="section">build:</span></span><br><span class="line">clang -g -O2 -target bpf -D__TARGET_ARCH_x86 -I/usr/<span class="keyword">include</span>/x86_64-linux-gnu -I. -c xdp-proxy.bpf.c -o xdp-proxy.bpf.o</span><br><span class="line">bpftool gen skeleton xdp-proxy.bpf.o &gt; xdp-proxy.skel.h</span><br><span class="line">clang -g -O2 -Wall -I. -c xdp-proxy.c -o xdp-proxy.o</span><br><span class="line">clang -Wall -O2 -g xdp-proxy.o -static -lbpf -lelf -lz -o xdp-proxy</span><br><span class="line"></span><br><span class="line"><span class="section">run:</span></span><br><span class="line"><span class="comment"># 复制字节码到容器中</span></span><br><span class="line">docker cp xdp-proxy.bpf.o lb:/</span><br><span class="line"><span class="comment"># 在容器中安装iproute2命令行工具</span></span><br><span class="line">docker exec -it lb apk add iproute2 --update</span><br><span class="line"><span class="comment"># 在容器中挂载XDP程序到eth0网卡</span></span><br><span class="line">docker exec -it lb ip link set dev eth0 xdpgeneric object xdp-proxy.bpf.o sec xdp</span><br></pre></td></tr></table></figure><hr><p>参考链接:</p><ul><li><a href="https://ebpf.io/what-is-ebpf/">https://ebpf.io/what-is-ebpf/</a></li><li><a href="https://www.brendangregg.com/ebpf.html">https://www.brendangregg.com/ebpf.html</a></li><li><a href="https://time.geekbang.org/column/intro/100104501">https://time.geekbang.org/column/intro/100104501</a></li><li><a href="https://github.com/champly/ebpf-learn-code">https://github.com/champly/ebpf-learn-code</a></li><li><a href="https://www.ebpf.top/post/ebpf_learn_path/">https://www.ebpf.top/post/ebpf_learn_path&#x2F;</a></li><li><a href="https://github.com/iovisor/bcc">https://github.com/iovisor/bcc</a></li><li><a href="https://github.com/libbpf/libbpf">https://github.com/libbpf/libbpf</a></li><li><a href="https://github.com/cilium/ebpf">https://github.com/cilium/ebpf</a></li><li><a href="https://www.usenix.org/conference/lisa21/presentation/gregg-bpf">https://www.usenix.org/conference/lisa21/presentation/gregg-bpf</a></li><li><a href="https://docs.cilium.io/en/stable/bpf/">https://docs.cilium.io/en/stable/bpf/</a></li><li><a href="https://github.com/iovisor/bpftrace">https://github.com/iovisor/bpftrace</a></li><li><a href="https://www.kernel.org/doc/htmldocs/networking/ch01s02.html">https://www.kernel.org/doc/htmldocs/networking/ch01s02.html</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;该文档主要是&lt;a href=&quot;https://time.geekbang.org/column/intro/100104501&quot;&gt;《eBPF 核心技术与实战》&lt;/a&gt;课程的笔记以及一些扩展。其中代码在&lt;a href=&quot;https://github.com/champly/ebpf-learn-code&quot;&gt;ebpf-learn-code&lt;/a&gt;仓库中，编译环境都在 &lt;code&gt;Docker&lt;/code&gt; 镜像中，也具备 &lt;a href=&quot;https://github.com/cilium/ebpf&quot;&gt;cilium-ebpf&lt;/a&gt; 的编译环境。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是eBPF&quot;&gt;&lt;a href=&quot;#什么是eBPF&quot; class=&quot;headerlink&quot; title=&quot;什么是eBPF&quot;&gt;&lt;/a&gt;什么是eBPF&lt;/h2&gt;&lt;p&gt;&lt;code&gt;eBPF&lt;/code&gt; 是从 &lt;code&gt;BPF&lt;/code&gt; 技术扩展而来的，得益于 &lt;code&gt;BPF&lt;/code&gt; 的设计:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内核态引入一个新的虚拟机(执行引擎)，所有指令都在内核虚拟机中运行；&lt;/li&gt;
&lt;li&gt;用户态使用 &lt;code&gt;BPF&lt;/code&gt; 字节码来定义过滤表达式，然后传递给内核，由内核虚拟机解释执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这就使得包过滤可以直接在内核中执行，避免了向用户态复制每个数据包，从而极大提升了包过滤的性能，进而被广大操作系统广泛接受。&lt;em&gt;而 &lt;code&gt;BPF&lt;/code&gt; 最初的名字由最初的 &lt;code&gt;BSD Packet Filter&lt;/code&gt; 变成了 &lt;code&gt;Berkeley Packet Filter&lt;/code&gt;&lt;/em&gt; 。&lt;/p&gt;
&lt;h3 id=&quot;发展历程&quot;&gt;&lt;a href=&quot;#发展历程&quot; class=&quot;headerlink&quot; title=&quot;发展历程&quot;&gt;&lt;/a&gt;发展历程&lt;/h3&gt;</summary>
    
    
    
    <category term="eBPF" scheme="http://example.com/categories/eBPF/"/>
    
    
    <category term="eBPF" scheme="http://example.com/tags/eBPF/"/>
    
  </entry>
  
  <entry>
    <title>Linux 进程管理(二)：任务调度</title>
    <link href="http://example.com/2022/07/31/os/linux_task_scheduling/"/>
    <id>http://example.com/2022/07/31/os/linux_task_scheduling/</id>
    <published>2022-07-31T00:06:22.000Z</published>
    <updated>2023-05-11T05:53:11.750Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 任务调度</p><h2 id="task-struct"><a href="#task-struct" class="headerlink" title="task_struct"></a>task_struct</h2><p>在 Linux 里面，无论是进程还是线程，到了内核里面，统一都叫任务（Task），由一个统一的结构体 <code>task_struct</code> 进行管理</p><p><img data-src="/images/os/linux_task_shceduling/task.jpeg" alt="task"></p><p>这个结构有点复杂，具体可以看相关 <a href="https://elixir.bootlin.com/linux/v5.19/source/include/linux/sched.h#L726">代码</a>。</p><h3 id="任务-ID"><a href="#任务-ID" class="headerlink" title="任务 ID"></a>任务 ID</h3><p>每一个任务都应该有一个任务 ID 作为唯一标识</p><p><a href="https://elixir.bootlin.com/linux/v5.19/source/include/linux/sched.h#L950">code</a></p><figure class="highlight c"><figcaption><span>include/linux/sched.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span>pid;</span><br><span class="line"><span class="type">pid_t</span>tgid;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="comment">/* Real parent process: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> __<span class="title">rcu</span>*<span class="title">real_parent</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Recipient of SIGCHLD, wait4() reports: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> __<span class="title">rcu</span>*<span class="title">parent</span>;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  * Children/sibling form the list of natural children:</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">children</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">sibling</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>*<span class="title">group_leader</span>;</span></span><br></pre></td></tr></table></figure><ul><li>pid（process ID）: 线程 ID</li><li>tgid（thread group ID）：主线程 ID，当前线程就是主线程，那么 tgid 就是 pid</li><li>parent: 指向其父进程。当它终止时，必须向它的父进程发送信号</li><li>children: 表示链表的头部。链表中的所有元素都是它的子进程</li><li>sibling: 用于把当前进程插入到兄弟链表中</li><li>group_leader：指向进程的主线程</li></ul><p>通过对比 tgid 和 pid 就可以知道当前 task_struct 是进程还是线程。如果只是想通过 ps 查看有多少进程，可以只展示 <code>pid == tgid</code> 的 task_struct，就不用把所有的都展示出来；如果想要结束一个进程，可以使用 kill 命令结束整个进程而不是线程。</p><blockquote><p>当然也有发送信号给单个线程的情况：可以看 Go Runtime 的抢占式调度的实现</p></blockquote><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>在 task_struct 的状态 <a href="https://elixir.bootlin.com/linux/v5.19/source/include/linux/sched.h#L83">code</a></p><figure class="highlight c"><figcaption><span>include/linux/sched.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Used in tsk-&gt;state: */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_RUNNING0x0000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_INTERRUPTIBLE0x0001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_UNINTERRUPTIBLE0x0002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TASK_STOPPED0x0004</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TASK_TRACED0x0008</span></span><br><span class="line"><span class="comment">/* Used in tsk-&gt;exit_state: */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXIT_DEAD0x0010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXIT_ZOMBIE0x0020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXIT_TRACE(EXIT_ZOMBIE | EXIT_DEAD)</span></span><br><span class="line"><span class="comment">/* Used in tsk-&gt;state again: */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_PARKED0x0040</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_DEAD0x0080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_WAKEKILL0x0100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_WAKING0x0200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_NOLOAD0x0400</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_NEW0x0800</span></span><br><span class="line"><span class="comment">/* RT specific auxilliary flag to mark RT lock waiters */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_RTLOCK_WAIT0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_STATE_MAX0x2000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Convenience macros for the sake of set_current_state: */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_KILLABLE(TASK_WAKEKILL | TASK_UNINTERRUPTIBLE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_STOPPED(TASK_WAKEKILL | __TASK_STOPPED)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_TRACED__TASK_TRACED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_IDLE(TASK_UNINTERRUPTIBLE | TASK_NOLOAD)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Convenience macros for the sake of wake_up(): */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_NORMAL(TASK_INTERRUPTIBLE | TASK_UNINTERRUPTIBLE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* get_task_state(): */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_REPORT(TASK_RUNNING | TASK_INTERRUPTIBLE | \</span></span><br><span class="line"><span class="meta"> TASK_UNINTERRUPTIBLE | __TASK_STOPPED | \</span></span><br><span class="line"><span class="meta"> __TASK_TRACED | EXIT_DEAD | EXIT_ZOMBIE | \</span></span><br><span class="line"><span class="meta"> TASK_PARKED)</span></span><br></pre></td></tr></table></figure><p><code>TASK_RUNNING</code> 并不是说进程正在运行，而是表示进程在时刻准备运行的状态。当处于这个状态的进程获得时间片的时候，就是在运行中；如果没有获得时间片，就说明它被其他进程抢占了，等待再次分配时间片。运行中的进程，一旦要进行一些 I&#x2F;O 操作，需要等待 I&#x2F;O 操作完毕，这个时候会主动释放 CPU，进入睡眠状态，在 Linux 中，有两种睡眠状态</p><ul><li>TASK_INTERRUPTIBLE：可中断的睡眠状态。虽然在睡眠，等待 I&#x2F;O 完成，但是这个时候一个信号来的时候，进程还是要被唤醒，只是唤醒之后不是继续刚才的操作，而是进行信号处理；</li><li>TASK_UNINTERRUPTIBLE：不可中断的睡眠状态。只能等待 I&#x2F;O 完成，连 kill 信号也会被忽略。除非重启电脑，没有其他办法；</li><li>TASK_KILLABLE：可终止的睡眠状态。进程处于这种状态中，原理和 TASK_UNINTERRUPTIBLE 类似，只不过是可以响应 kill 信号；</li><li>TASK_STOPPED：在进程收到 SIGSTOP、SIGTTIN、SIGTSTP 或者 SIGTTOU 信号之后进入该状态；</li><li>TASK_TRACED：表示进程被 debugger 等进程监控，进程执行被调试程序所停止。当一个进程被另外的进程所监视，每一个信号都会让该进程进入这个状态；</li><li>EXIT_ZOMBIE：一旦一个进程要结束，先进入这个状态，但是这个时候它的父进程还没有使用 wait() 等系统调用来获取它的终止信息，此时进程就成了僵尸进程；</li><li>EXIT_DEAD：是进程的最终状态</li></ul><p>状态转换如下所示：</p><pre><code class="highlight mermaid">stateDiagramstate &quot;p-&gt;state = TASK_RUNNING&quot; as pstatestate &quot;运行&quot; as run[*] --&gt;  sys_forksys_fork --&gt; _do_fork_do_fork --&gt; wake_up_new_taskwake_up_new_task --&gt; pstatepstate --&gt; TASK_RUNNINGTASK_RUNNING --&gt; run: 分配 CPUrun --&gt; TASK_RUNNING: 时间片使用完毕或被抢占run --&gt; TASK_INTERRUPTIBLErun --&gt; TASK_UNINTERRUPTIBLErun --&gt; TASK_KILLABLETASK_INTERRUPTIBLE --&gt; TASK_RUNNINGTASK_UNINTERRUPTIBLE --&gt; TASK_RUNNINGTASK_KILLABLE --&gt; TASK_RUNNINGrun --&gt; TASK_STOPPEDrun --&gt; EXIT_ZOMBIE: exitEXIT_ZOMBIE --&gt; EXIT_DEADEXIT_DEAD --&gt; [*]</code></pre><h3 id="运行统计信息"><a href="#运行统计信息" class="headerlink" title="运行统计信息"></a>运行统计信息</h3><p>主要包含在下面这些字段中 <a href="https://elixir.bootlin.com/linux/v5.19/source/include/linux/sched.h#L1002">code</a></p><figure class="highlight c"><figcaption><span>include/linux/sched.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">u64utime;  <span class="comment">// 用户态消耗的 CPU 时间</span></span><br><span class="line">u64stime;  <span class="comment">// 内核态消耗的 CPU 时间</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARCH_HAS_SCALED_CPUTIME</span></span><br><span class="line">u64utimescaled;</span><br><span class="line">u64stimescaled;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">u64gtime;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">prev_cputime</span><span class="title">prev_cputime</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_VIRT_CPU_ACCOUNTING_GEN</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vtime</span><span class="title">vtime</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NO_HZ_FULL</span></span><br><span class="line"><span class="type">atomic_t</span>tick_dep_mask;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/* Context switch counts: */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>nvcsw;  <span class="comment">// 自愿(voluntary)上下文切换计数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>nivcsw; <span class="comment">// 非自愿(involuntary)上下文切换计数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Monotonic time in nsecs: */</span></span><br><span class="line">u64start_time;     <span class="comment">// 进程启动时间，不包含睡眠时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Boot based time in nsecs: */</span></span><br><span class="line">u64start_boottime; <span class="comment">// 进程启动时间，包含睡眠时间</span></span><br></pre></td></tr></table></figure><h2 id="调度原理"><a href="#调度原理" class="headerlink" title="调度原理"></a>调度原理</h2><p>在 Linux 里面，进程可以分为两种：实时进程和普通进程。</p><ul><li>实时进程：需要尽快执行返回结果的那种</li><li>普通进程：大部分进程其实都是这种</li></ul><h3 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h3><p>在 task_struct 中 的 <a href="https://elixir.bootlin.com/linux/v5.19/source/include/linux/sched.h#L816">policy</a> 用来表示调度策略，有以下一些策略 <a href="https://elixir.bootlin.com/linux/v5.19/source/include/uapi/linux/sched.h#L114">code</a></p><figure class="highlight c"><figcaption><span>include/uapi/linux/sched.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Scheduling policies</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_NORMAL0  <span class="comment">// SCHED_OTHER</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_FIFO1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_RR2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_BATCH3</span></span><br><span class="line"><span class="comment">/* SCHED_ISO: reserved but not implemented yet */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_IDLE5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_DEADLINE6</span></span><br></pre></td></tr></table></figure><p>配合调度策略的，还有优先级</p><figure class="highlight c"><figcaption><span>include/linux/sched.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>prio;</span><br><span class="line"><span class="type">int</span>static_prio;</span><br><span class="line"><span class="type">int</span>normal_prio;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>rt_priority;</span><br></pre></td></tr></table></figure><p>优先级其实就是一个数值，对于实时进程，优先级范围是 0～99；对于普通进程，优先级范围是 100~139。数值越小，优先级越高。</p><h4 id="实时调度策略"><a href="#实时调度策略" class="headerlink" title="实时调度策略"></a>实时调度策略</h4><p>SCHED_FIFO、SCHED_RR、SCHED_DEADLINE 是实时进程的调度策略</p><ul><li>SCHED_FIFO：先来先执行</li><li>SCHED_RR：轮流调度，采用时间片，相同优先级的任务当用完时间片会被放到队列尾部，以保证公平性，而更高优先级的任务也是可以抢占低优先级的任务</li><li>SCHED_DEADLINE：按照任务的 deadline 进行调度的。DL 调度器总是选择其 deadline 距离当前时间点最近的那个任务，并调度它执行</li></ul><h4 id="普通调度策略"><a href="#普通调度策略" class="headerlink" title="普通调度策略"></a>普通调度策略</h4><p>SCHED_NORMAL、SCHED_BATCH、SCHED_IDLE 是普通进程的调度策略</p><ul><li>SCHED_NORMAL: 普通进程一般都是这个调度策略</li><li>SCHED_BATCH: 后台进程，几乎不需要和前段进行交互</li><li>SCHED_IDLE: 特别空闲的时候才跑的进程</li></ul><h4 id="修改-x2F-查看调度策略"><a href="#修改-x2F-查看调度策略" class="headerlink" title="修改&#x2F;查看调度策略"></a>修改&#x2F;查看调度策略</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">!690 # chrt -p 3986612</span><br><span class="line">pid 3986612&#x27;s current scheduling policy: SCHED_OTHER</span><br><span class="line">pid 3986612&#x27;s current scheduling priority: 0</span><br><span class="line"></span><br><span class="line">!698 # chrt  -f -p 10 3986612</span><br><span class="line">pid 3986612&#x27;s current scheduling policy: SCHED_FIFO</span><br><span class="line">pid 3986612&#x27;s current scheduling priority: 10</span><br><span class="line"></span><br><span class="line">!692 # chrt</span><br><span class="line">Show or change the real-time scheduling attributes of a process.</span><br><span class="line"></span><br><span class="line">Set policy:</span><br><span class="line"> chrt [options] &lt;priority&gt; &lt;command&gt; [&lt;arg&gt;...]</span><br><span class="line"> chrt [options] --pid &lt;priority&gt; &lt;pid&gt;</span><br><span class="line"></span><br><span class="line">Get policy:</span><br><span class="line"> chrt [options] -p &lt;pid&gt;</span><br><span class="line"></span><br><span class="line">Policy options:</span><br><span class="line"> -b, --batch          set policy to SCHED_BATCH</span><br><span class="line"> -d, --deadline       set policy to SCHED_DEADLINE</span><br><span class="line"> -f, --fifo           set policy to SCHED_FIFO</span><br><span class="line"> -i, --idle           set policy to SCHED_IDLE</span><br><span class="line"> -o, --other          set policy to SCHED_OTHER</span><br><span class="line"> -r, --rr             set policy to SCHED_RR (default)</span><br><span class="line"></span><br><span class="line">Scheduling options:</span><br><span class="line"> -R, --reset-on-fork       set SCHED_RESET_ON_FORK for FIFO or RR</span><br><span class="line"> -T, --sched-runtime &lt;ns&gt;  runtime parameter for DEADLINE</span><br><span class="line"> -P, --sched-period &lt;ns&gt;   period parameter for DEADLINE</span><br><span class="line"> -D, --sched-deadline &lt;ns&gt; deadline parameter for DEADLINE</span><br><span class="line"></span><br><span class="line">Other options:</span><br><span class="line"> -a, --all-tasks      operate on all the tasks (threads) for a given pid</span><br><span class="line"> -m, --max            show min and max valid priorities</span><br><span class="line"> -p, --pid            operate on existing given pid</span><br><span class="line"> -v, --verbose        display status information</span><br><span class="line"></span><br><span class="line"> -h, --help     display this help and exit</span><br><span class="line"> -V, --version  output version information and exit</span><br><span class="line"></span><br><span class="line">For more details see chrt(1).</span><br></pre></td></tr></table></figure><p>不管是 policy 还是 priority，都是一个变量，真正做调度的是 <a href="https://elixir.bootlin.com/linux/v5.19/source/include/linux/sched.h#L780">sched_class</a></p><h3 id="调度策略实现"><a href="#调度策略实现" class="headerlink" title="调度策略实现"></a>调度策略实现</h3><p>sched_class 有这些实现 <a href="https://elixir.bootlin.com/linux/v5.19/source/kernel/sched/sched.h#L2213">code</a></p><figure class="highlight c"><figcaption><span>kernel/sched/sched.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">stop_sched_class</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">dl_sched_class</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">rt_sched_class</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">fair_sched_class</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">idle_sched_class</span>;</span></span><br></pre></td></tr></table></figure><ul><li>stop_sched_class: 优先级最高的任务会使用这种策略，会中断所有其他线程，且不会被其他任务打断</li><li>dl_sched_class: 对应 deadline 调度策略</li><li>rt_sched_class: 对应 RR 算法或者 FIFO 算法的调度策略，具体调度策略由 task_struct-&gt;policy 指定</li><li>fair_sched_class: 普通进程的调度策略</li><li>idle_sched_class: 空闲进程的调度策略</li></ul><p>这里实时进程的调度策略 RR 和 FIFO 相对简单一些，平时遇到的基本上都是普通进程，这里重点分析普通进程的调度，也就是 fair_sched_class。</p><h3 id="CFS"><a href="#CFS" class="headerlink" title="CFS"></a>CFS</h3><p>在 Linux 里面，实现了一个基于 CFS(Completely Fair Scheduling) 的调度算法。CPU 会提供一个时钟，过一段时间就触发一个时钟中断。CFS 为每个进程设置一个虚拟运行时间 vruntime。如果一个进程在运行，随着时间的增加，也就是一个个 tick 的到来，进程的 vruntime 将不断增大。没有得到运行的进程 vruntime 不变。vruntime 小的进程，会优先运行进程。<a href="https://elixir.bootlin.com/linux/v5.19/source/kernel/sched/fair.c#L888">code</a></p><figure class="highlight c"><figcaption><span>kernel/sched/fair.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Update the current task&#x27;s runtime statistics.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">update_curr</span><span class="params">(<span class="keyword">struct</span> cfs_rq *cfs_rq)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">curr</span> =</span> cfs_rq-&gt;curr;</span><br><span class="line">u64 now = rq_clock_task(rq_of(cfs_rq));</span><br><span class="line">u64 delta_exec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!curr))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">delta_exec = now - curr-&gt;exec_start;</span><br><span class="line"><span class="keyword">if</span> (unlikely((s64)delta_exec &lt;= <span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">curr-&gt;exec_start = now;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">curr-&gt;vruntime += calc_delta_fair(delta_exec, curr);</span><br><span class="line">update_min_vruntime(cfs_rq);</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * delta /= w</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> u64 <span class="title function_">calc_delta_fair</span><span class="params">(u64 delta, <span class="keyword">struct</span> sched_entity *se)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (unlikely(se-&gt;load.weight != NICE_0_LOAD))</span><br><span class="line">delta = __calc_delta(delta, NICE_0_LOAD, &amp;se-&gt;load);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/sched.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> &#123;</span></span><br><span class="line"><span class="comment">/* For load-balancing: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span><span class="title">load</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span><span class="title">run_node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">group_node</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>on_rq;</span><br><span class="line"></span><br><span class="line">u64exec_start;</span><br><span class="line">u64sum_exec_runtime;</span><br><span class="line">u64vruntime;</span><br><span class="line">u64prev_sum_exec_runtime;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>开始运行的时间减去当前时间，就是这次运行的时间 delta_exec，然后通过 calc_delta_fair 计算得到最终的 vruntime</p><blockquote><p>vruntime +&#x3D; 真实运行的时间 * NICE_0_LOAD &#x2F; 进程权重</p></blockquote><p>进程每次运行完毕后就会更新 vruntime，然后选择 vruntime 最小的进程继续运行，这将由红黑树完成。</p><h3 id="调度队列与调度实体"><a href="#调度队列与调度实体" class="headerlink" title="调度队列与调度实体"></a>调度队列与调度实体</h3><p>上面说到的红黑树的节点，应该是包括 vruntime 的，称为调度实体，在 task_struct 中，有这些<a href="https://elixir.bootlin.com/linux/v5.19/source/include/linux/sched.h#L777">变量</a></p><figure class="highlight c"><figcaption><span>include/linux/sched.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task_struct</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span><span class="title">se</span>;</span><span class="comment">// CFS 公平算法调度实体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_rt_entity</span><span class="title">rt</span>;</span> <span class="comment">// 实时调度实体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_dl_entity</span><span class="title">dl</span>;</span><span class="comment">// Deadline 调度实体</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> &#123;</span></span><br><span class="line"><span class="comment">/* For load-balancing: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span><span class="title">load</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span><span class="title">run_node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">group_node</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>on_rq;</span><br><span class="line"></span><br><span class="line">u64exec_start;</span><br><span class="line">u64sum_exec_runtime;</span><br><span class="line">u64vruntime;</span><br><span class="line">u64prev_sum_exec_runtime;</span><br><span class="line"></span><br><span class="line">u64nr_migrations;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>进程根据自己是实时的，还是普通的，通过变量将自己挂到某一个调度队列里面，和其它进程排序，等待被调度。如果是普通进程，就将 sched_entity 挂到红黑树上。而真正维护这些队列的就是 CPU，所以每个 CPU 都有自己的 <a href="https://elixir.bootlin.com/linux/v5.19/source/kernel/sched/sched.h#L918"><code>struct rq</code></a> 结构</p><figure class="highlight c"><figcaption><span>kernel/sched/sched.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rq</span> &#123;</span></span><br><span class="line"><span class="comment">/* runqueue lock: */</span></span><br><span class="line"><span class="type">raw_spinlock_t</span>__lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * nr_running and cpu_load should be in the same cacheline because</span></span><br><span class="line"><span class="comment"> * remote CPUs use both these fields when doing load calculation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>nr_running;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span><span class="title">cfs</span>;</span><span class="comment">// CFS 运行队列</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_rq</span><span class="title">rt</span>;</span><span class="comment">// 实时进程运行队列</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dl_rq</span><span class="title">dl</span>;</span><span class="comment">// Deadline 运行队列</span></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is part of a global counter where only the total sum</span></span><br><span class="line"><span class="comment"> * over all CPUs matters. A task can increase this counter on</span></span><br><span class="line"><span class="comment"> * one CPU and if it got migrated afterwards it may decrease</span></span><br><span class="line"><span class="comment"> * it on another CPU. Always updated under the runqueue lock:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>nr_uninterruptible;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> __<span class="title">rcu</span>*<span class="title">curr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>*<span class="title">idle</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>*<span class="title">stop</span>;</span></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于普通进程公平队列 cfs_rq 中的 <a href="https://elixir.bootlin.com/linux/v5.19/source/kernel/sched/sched.h#L542"><code>tasks_timeline</code></a> 就是指向红黑树的根节点。调度的时候会先判断是否有实时进程需要运行，如果没有，才会去 CFS 运行队列面找 vruntime 最小的进程运行</p><figure class="highlight c"><figcaption><span>kernel/sched/core.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Pick up the highest-prio task:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *</span></span><br><span class="line"><span class="class">__<span class="title">pick_next_task</span>(<span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>, <span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">prev</span>, <span class="keyword">struct</span> <span class="title">rq_flags</span> *<span class="title">rf</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="keyword">class</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Optimization: we know that if all tasks are in the fair class we can</span></span><br><span class="line"><span class="comment"> * call that function directly, but only if the @prev task wasn&#x27;t of a</span></span><br><span class="line"><span class="comment"> * higher scheduling class, because otherwise those lose the</span></span><br><span class="line"><span class="comment"> * opportunity to pull in more work from other CPUs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (likely(!sched_class_above(prev-&gt;sched_class, &amp;fair_sched_class) &amp;&amp;</span><br><span class="line">   rq-&gt;nr_running == rq-&gt;cfs.h_nr_running)) &#123;</span><br><span class="line"></span><br><span class="line">p = pick_next_task_fair(rq, prev, rf);</span><br><span class="line"><span class="keyword">if</span> (unlikely(p == RETRY_TASK))</span><br><span class="line"><span class="keyword">goto</span> restart;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Assume the next prioritized class is idle_sched_class */</span></span><br><span class="line"><span class="keyword">if</span> (!p) &#123;</span><br><span class="line">put_prev_task(rq, prev);</span><br><span class="line">p = pick_next_task_idle(rq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">restart:</span><br><span class="line">put_prev_task_balance(rq, prev, rf);</span><br><span class="line"></span><br><span class="line">for_each_class(class) &#123;</span><br><span class="line">p = class-&gt;pick_next_task(rq);</span><br><span class="line"><span class="keyword">if</span> (p)</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BUG(); <span class="comment">/* The idle class should always have a runnable task. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>for_each_class</code> 就是 <a href="https://elixir.bootlin.com/linux/v5.19/source/kernel/sched/sched.h#L2213">依次</a> 循环，调用每个调度类的方法。这样整个运行的场景就可以串起来了，在每个 CPU 上都有一个队列 rq，这个队列包含了不同优先级的队列：rt_rq、cfs_rq 等，不同队列实现方式不一样，当某个 CPU 需要找下一个任务执行的时候，会按照优先级依次调用调度类，第一个没有找到才能找下一个调度类的任务，最终找到下个任务继续运行，这样就能保证实时任务的优先级永远大于普通任务。</p><h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><p>计算机主要处理计算、网络、存储三个方面。计算主要是 CPU 和内存的合作；网络和存储则多是和外部设备合作；在操作外部设备的时候，往往需要让出 CPU，调用 <a href="https://elixir.bootlin.com/linux/v5.19/source/kernel/sched/core.c#L6523"><code>schedule()</code></a> 函数</p><figure class="highlight c"><figcaption><span>kernel/sched/core.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage __visible <span class="type">void</span> __sched <span class="title function_">schedule</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> =</span> current;</span><br><span class="line"></span><br><span class="line">sched_submit_work(tsk);</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">preempt_disable();</span><br><span class="line">__schedule(SM_NONE);</span><br><span class="line">sched_preempt_enable_no_resched();</span><br><span class="line">&#125; <span class="keyword">while</span> (need_resched());</span><br><span class="line">sched_update_worker(tsk);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(schedule);</span><br></pre></td></tr></table></figure><p>schedule 的主要逻辑都是在 <code>__schedule</code> 里面实现的</p><h3 id="schedule"><a href="#schedule" class="headerlink" title="__schedule"></a>__schedule</h3><pre><code class="highlight mermaid">flowchartschedule --&gt; __schedule__schedule -- 1 --&gt; pick_next_taskpick_next_task --&gt; __pick_next_task__pick_next_task --&gt; pick_next_task_fair__pick_next_task --&gt; other[class-&gt;pick_next_task]other --&gt; other-logicpick_next_task_fair --&gt; 1.update_curr1.update_curr --&gt; update-vruntimepick_next_task_fair --&gt; 2.pick_next_entity2.pick_next_entity --&gt; __pick_first_entity__pick_first_entity -- 2 return next --&gt; __schedule__schedule -- 3 --&gt; context_switch</code></pre><ul><li>取出当前 CPU 上的任务队列 rq，以及正在运行的进程 curr</li><li>获取下一个要执行的任务</li><li>如果是 CFS，就要更新 vruntime，然后取红黑树最左边的节点(vruntime 最小的任务)</li><li>判断当前进程和下一个要执行的任务是否是同一个任务，如果不是，调用 context_switch</li></ul><p><a href="https://elixir.bootlin.com/linux/v5.19/source/kernel/sched/core.c#L5094">context_switch</a> 主要的逻辑就是上下文切换</p><ul><li>切换进程空间，即虚拟内存</li><li>切换寄存器和 CPU 上下文</li></ul><p>task_struct 里面有一个 <a href="https://elixir.bootlin.com/linux/v5.19/source/include/linux/sched.h#L1510">thread</a> 的变量，保留了要切换进程的时候需要修改的寄存器。</p><p>进程调度都会走到 __schedule 这里，如果是主动调用 schedule 就是主动让出，那如果不主动让出呢？</p><h3 id="抢占式调度"><a href="#抢占式调度" class="headerlink" title="抢占式调度"></a>抢占式调度</h3><h4 id="抢占过程"><a href="#抢占过程" class="headerlink" title="抢占过程"></a>抢占过程</h4><p>最常见的现象就是一个进程执行时间太长，不主动让出 CPU，这个时候不能一直让这个进程继续运行，需要切换到另外一个进程。衡量这个时间点，就是计算机里面的时钟，每过一段时间（调度周期）就会触发一次时钟中断，这个时候 CPU 会切换任务去响应这个时钟中断，这个时候就可以查看是否需要抢占。时钟中断处理函数主要是 <a href="https://elixir.bootlin.com/linux/v5.19/source/kernel/sched/core.c#L5400">scheduler_tick</a></p><pre><code class="highlight mermaid">flowchart LRscheduler_tick --&gt; task_ticktask_tick -- 根据 sched_class 判断 --&gt; task_tick_fairtask_tick_fair --&gt; entity_tickentity_tick --&gt; 1.update_currentity_tick --&gt; 2.check_preempt_tick</code></pre><p>主要的就是 <a href="https://elixir.bootlin.com/linux/v5.19/source/kernel/sched/fair.c#L4485">check_preempt_tick</a>，检查是否是应该抢占当前进程</p><figure class="highlight c"><figcaption><span>kernel/sched/fair.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Preempt the current task with a newly woken task if needed:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">check_preempt_tick</span><span class="params">(<span class="keyword">struct</span> cfs_rq *cfs_rq, <span class="keyword">struct</span> sched_entity *curr)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> ideal_runtime, delta_exec;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">se</span>;</span></span><br><span class="line">s64 delta;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ideal_runtime 一个调度周期中，运行的“实际”(理论)时间</span></span><br><span class="line">ideal_runtime = sched_slice(cfs_rq, curr);</span><br><span class="line">  <span class="comment">// delta_exec 这次调度运行的时间</span></span><br><span class="line">delta_exec = curr-&gt;sum_exec_runtime - curr-&gt;prev_sum_exec_runtime;</span><br><span class="line"><span class="keyword">if</span> (delta_exec &gt; ideal_runtime) &#123;</span><br><span class="line">resched_curr(rq_of(cfs_rq));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The current task ran long enough, ensure it doesn&#x27;t get</span></span><br><span class="line"><span class="comment"> * re-elected due to buddy favours.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">clear_buddies(cfs_rq, curr);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ensure that a task that missed wakeup preemption by a</span></span><br><span class="line"><span class="comment"> * narrow margin doesn&#x27;t have to wait for a full slice.</span></span><br><span class="line"><span class="comment"> * This also mitigates buddy induced latencies under load.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (delta_exec &lt; sysctl_sched_min_granularity)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取出红黑树最小的进程</span></span><br><span class="line">se = __pick_first_entity(cfs_rq);</span><br><span class="line">delta = curr-&gt;vruntime - se-&gt;vruntime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (delta &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (delta &gt; ideal_runtime)</span><br><span class="line">resched_curr(rq_of(cfs_rq));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果发现当前进程运行过长或者当前进程的 vruntime 大于红黑树中最小的进程的 vruntime，就会调用 resched_curr 标记当前进程为被抢占，而不是真正的抢占，而是打上一个标签 TIF_NEED_RESCHED</p><p>另外一个可能抢占的场景就是当一个进程被唤醒的时候。当一个进程在等待 I&#x2F;O 当时候，会主动放弃 CPU，但是当 I&#x2F;O 到来的时候，进程往往会被唤醒。这时候是一个时机。当被唤醒的进程优先级高于 CPU 上的当前进程，就会触发抢占。</p><pre><code class="highlight mermaid">flowchart LRtry_to_wake_up --&gt; ttwu_queuettwu_queue --&gt; ttwu_do_activatettwu_do_activate --&gt; ttwu_do_wakeupttwu_do_wakeup --&gt; check_preempt_curr</code></pre><p>到这里，只是把进程标记为被抢占，但是没有发生真正的抢占动作</p><h4 id="抢占时机"><a href="#抢占时机" class="headerlink" title="抢占时机"></a>抢占时机</h4><p>真正的抢占时机，是让正在运行的进程有机会调用 schedule。</p><p>对于用户态进程来讲，从系统调用返回的那个时候，就是一个被抢占的时机。</p><p>对于内核态的执行中，被抢占的时机一般发生在 preempt_enable() 中。对于内核有些操作不能被中断，所以一般都会 preempt_disable() 关闭抢占，当再次打开就是一次抢占的机会。还有就是从中断返回的时候返回的也是内核态，这个时候也是一个执行抢占的时机。</p><hr><p>参考链接:</p><ul><li><a href="https://mp.weixin.qq.com/s/HFQL5d-C24DKjQbYAQfl8g">https://mp.weixin.qq.com/s/HFQL5d-C24DKjQbYAQfl8g</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247501576&idx=1&sn=657e1c89d1007a935820d394d64f4035&scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz&#x3D;Mzk0MjE3NDE0Ng&#x3D;&#x3D;&amp;mid&#x3D;2247501576&amp;idx&#x3D;1&amp;sn&#x3D;657e1c89d1007a935820d394d64f4035&amp;scene&#x3D;21#wechat_redirect</a></li><li><a href="https://zhuanlan.zhihu.com/p/79772089">https://zhuanlan.zhihu.com/p/79772089</a></li><li><a href="https://www.jianshu.com/p/0d90b92000c0">https://www.jianshu.com/p/0d90b92000c0</a></li><li><a href="https://segmentfault.com/a/1190000039367851?utm_source=sf-similar-article">https://segmentfault.com/a/1190000039367851?utm_source&#x3D;sf-similar-article</a></li><li><a href="https://www.cnblogs.com/chaojiyingxiong/p/15799617.html">https://www.cnblogs.com/chaojiyingxiong/p/15799617.html</a></li><li><a href="http://www.wowotech.net/process_management/scheduler-history.html">http://www.wowotech.net/process_management&#x2F;scheduler-history.html</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-scheduler/index.html">https://www.ibm.com/developerworks/cn/linux/l-cn-scheduler/index.html</a></li><li><a href="https://www.jianshu.com/p/673c9e4817a8">https://www.jianshu.com/p/673c9e4817a8</a></li><li><a href="https://blog.eastonman.com/blog/2021/02/cfs/">https://blog.eastonman.com/blog/2021/02/cfs/</a></li><li><a href="https://www.kernel.org/doc/html/latest/scheduler/sched-design-CFS.html">https://www.kernel.org/doc/html/latest/scheduler/sched-design-CFS.html</a></li><li><a href="https://time.geekbang.org/column/intro/100024701?tab=catalog">https://time.geekbang.org/column/intro/100024701?tab=catalog</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Linux 任务调度&lt;/p&gt;
&lt;h2 id=&quot;task-struct&quot;&gt;&lt;a href=&quot;#task-struct&quot; class=&quot;headerlink&quot; title=&quot;task_struct&quot;&gt;&lt;/a&gt;task_struct&lt;/h2&gt;&lt;p&gt;在 Linux 里面，无论是进程还是线程，到了内核里面，统一都叫任务（Task），由一个统一的结构体 &lt;code&gt;task_struct&lt;/code&gt; 进行管理&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;/images/os/linux_task_shceduling/task.jpeg&quot; alt=&quot;task&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个结构有点复杂，具体可以看相关 &lt;a href=&quot;https://elixir.bootlin.com/linux/v5.19/source/include/linux/sched.h#L726&quot;&gt;代码&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;任务-ID&quot;&gt;&lt;a href=&quot;#任务-ID&quot; class=&quot;headerlink&quot; title=&quot;任务 ID&quot;&gt;&lt;/a&gt;任务 ID&lt;/h3&gt;</summary>
    
    
    
    <category term="OS" scheme="http://example.com/categories/OS/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 进程管理(一)：进程和线程</title>
    <link href="http://example.com/2022/07/30/os/linux_process_and_thread/"/>
    <id>http://example.com/2022/07/30/os/linux_process_and_thread/</id>
    <published>2022-07-30T00:06:22.000Z</published>
    <updated>2023-05-11T05:53:11.750Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 进程和线程</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程的定义如下:</p><blockquote><p>进程（Process）是指计算机已执行的程序，用户下达执行进程的命令后，就会产生进程。同一个程序可以产生多个进程（一对多），以允许同时有多个用户执行同一个程序，却不会相互冲突。进程需要一些资源才能完成工作，比如 CPU、内存、存储、文件以及 I&#x2F;O 设备等。</p></blockquote><p>这里说的程序，一般都是 ELF 格式的可执行文件。</p><h3 id="ELF"><a href="#ELF" class="headerlink" title="ELF"></a>ELF</h3><p>ELF(Executable and Linking Format) 一般有这几种格式:</p><ul><li>可重定位文件</li><li>可执行文件</li><li>共享对象文件</li><li>内核转储文件</li></ul><h4 id="可重定位文件"><a href="#可重定位文件" class="headerlink" title="可重定位文件"></a>可重定位文件</h4><p>可重定位文件（Relocatable File）包含适用于与其他目标文件链接来创建可执行文件或者共享目标文件的代码和数据，一般都是 *.o 文件，这个编译好的二进制文件里面，应该是代码，还有一些全局变量、静态变量等等。</p><blockquote><p>为什么这里只有全局变量呢？是因为局部变量放到栈里面的，是程序运行过程中随时分配的空间，随时释放的，这里还是二进制文件，还没有启动，所以只有全局变量</p></blockquote><p>这个编译好的代码和变量，将来加载到内存里面的时候，都是要加载到一定位置的。比如调用一个函数，其实就是跳到这个函数所在的代码位置执行；如果修改全局变量，也要到变量的位置那里修改。但是在这个时候，还是 *.o 文件，不是一个可直接运行的程序。所以 *.o 里面的位置是不确定的，但是必须是可重新定位的，因为它将来是要做函数库的，加载到哪里就重新定位这些代码、变量的位置。</p><h4 id="可执行文件"><a href="#可执行文件" class="headerlink" title="可执行文件"></a>可执行文件</h4><p>可执行文件（Executable File）包含适合执行的一个程序，此文件规定了 exec() 如何创建一个程序的进程映像，即 *.out 文件。格式基本上和 *.o 文件大致相似，只不过有多个 *.o 合并过的。这个文件是可以直接加载到内存里面执行的文件了，在 ELF 头里面，有一项 e_entry，也是个虚拟地址，是这个程序运行的入口。一般断点调试的时候可以第一个断点标记到这里</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -it --<span class="built_in">rm</span> --name centos centos:7.9.2009</span></span><br><span class="line">[root@fe87ccfdbd0a /]# readelf -h /usr/bin/ls</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&#x27;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              EXEC (Executable file)</span><br><span class="line">  Machine:                           AArch64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x404aa8</span><br><span class="line">  Start of program headers:          64 (bytes into file)</span><br><span class="line">  Start of section headers:          136320 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           56 (bytes)</span><br><span class="line">  Number of program headers:         9</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         30</span><br><span class="line">  Section header string table index: 29</span><br></pre></td></tr></table></figure><p>通过 readelf 可以查看到这个 Entry point address</p><h4 id="共享对象文件"><a href="#共享对象文件" class="headerlink" title="共享对象文件"></a>共享对象文件</h4><p>共享对象文件（Shared Object File）包含可在两种上下文中链接的代码和数据，首先链接编译器可以将它和其它重定位文件和动态链接库一起处理，生成另外一个目标文件。其次，动态链接器（Dynamic Linker）可能将它与某个可执行文件以及其它共享对象文件一起组合，创建进程映像。即 *.so 文件。</p><h4 id="内核转储"><a href="#内核转储" class="headerlink" title="内核转储"></a>内核转储</h4><p>内核转储（core dumps）存放当前进程的执行上下文，用于 dump 信号触发。</p><p>知道了 ELF 这个格式，这个时候它还是一个程序，需要加载到内存里面。</p><h3 id="启动进程"><a href="#启动进程" class="headerlink" title="启动进程"></a>启动进程</h3><p>在内核中，有这样一个数据结构，用来定义加载二进制文件的方法:</p><figure class="highlight c"><figcaption><span>include/linux/binfmts.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This structure defines the functions that are used to load the binary formats that</span></span><br><span class="line"><span class="comment"> * linux accepts.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lh</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">module</span>;</span></span><br><span class="line"><span class="type">int</span> (*load_binary)(<span class="keyword">struct</span> linux_binprm *);</span><br><span class="line"><span class="type">int</span> (*load_shlib)(<span class="keyword">struct</span> file *);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COREDUMP</span></span><br><span class="line"><span class="type">int</span> (*core_dump)(<span class="keyword">struct</span> coredump_params *cprm);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> min_coredump;<span class="comment">/* minimal dump size */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p>对于 ELF 文件格式，有对应的实现</p><figure class="highlight c"><figcaption><span>fs/binfmt_elf.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> <span class="title">elf_format</span> =</span> &#123;</span><br><span class="line">.module= THIS_MODULE,</span><br><span class="line">.load_binary= load_elf_binary,</span><br><span class="line">.load_shlib= load_elf_library,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COREDUMP</span></span><br><span class="line">.core_dump= elf_core_dump,</span><br><span class="line">.min_coredump= ELF_EXEC_PAGESIZE,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到最终是通过 load_elf_binary 加载的，这里就不继续深入了。</p><h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><p>使用代码来创建进程</p><figure class="highlight c"><figcaption><span>process.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world (pid:%d)\n&quot;</span>, (<span class="type">int</span>)getpid());</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> rc = fork();</span><br><span class="line"><span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork failed\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello, I am child (pid:%d)\n&quot;</span>,(<span class="type">int</span>)getpid());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> wc = wait(<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello, I am parent of %d (wc:%d) (pid:%d)\n&quot;</span>, rc, wc, (<span class="type">int</span>)getpid());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@ec2c598cce50 /]# gcc process.c -o process</span><br><span class="line">[root@ec2c598cce50 /]# ./process</span><br><span class="line">hello world (pid:115)</span><br><span class="line">hello, I am child (pid:116)</span><br><span class="line">hello, I am parent of 116 (wc:116) (pid:115)</span><br></pre></td></tr></table></figure><p>可以看到上面的父进程通过 fork 这个系统调用创建了子进程。如果在上面添加一个休眠，就可以通过 ps 查看到两个进程</p><figure class="highlight diff"><figcaption><span>process.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;hello world (pid:%d)\n&quot;, (int)getpid());</span><br><span class="line"></span><br><span class="line">int rc = fork();</span><br><span class="line">if (rc &lt; 0) &#123;</span><br><span class="line">fprintf(stderr, &quot;fork failed\n&quot;);</span><br><span class="line">exit(1);</span><br><span class="line">&#125; else if (rc == 0)&#123;</span><br><span class="line">printf(&quot;hello, I am child (pid:%d)\n&quot;,(int)getpid());</span><br><span class="line"><span class="addition">+sleep(10);</span></span><br><span class="line">&#125; else &#123;</span><br><span class="line">int wc = wait(NULL);</span><br><span class="line">printf(&quot;hello, I am parent of %d (wc:%d) (pid:%d)\n&quot;, rc, wc, (int)getpid());</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续运行发现不会退出，因为 <code>wait(NULL)</code>，父进程需要等待子进程退出，所以通过 ps 查看进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@ec2c598cce50 /]# ps -ef</span><br><span class="line">UID          PID    PPID  C STIME TTY          TIME CMD</span><br><span class="line">root           1       0  0 5月28 ?        00:00:16 /usr/lib/systemd/systemd --switched-root --system --deserialize 21</span><br><span class="line">root           2       0  0 5月28 ?        00:00:00 [kthreadd]</span><br><span class="line">root           3       2  0 5月28 ?        00:00:00 [rcu_gp]</span><br><span class="line">root           4       2  0 5月28 ?        00:00:00 [rcu_par_gp]</span><br><span class="line">......</span><br><span class="line">root         148       1  0 09:10 pts/0    00:00:00 ./process</span><br><span class="line">root         149     148  0 09:10 pts/0    00:00:00 ./process</span><br><span class="line">root         150     117  0 09:10 pts/1    00:00:00 ps -ef</span><br></pre></td></tr></table></figure><p>可以看到 148、149 都是 process 这个进程，只不过，148 的 PPID 是 1，而 149 的 PPID 是 148（父进程）。还可以看到 1 号进程的父进程是 0 号进程，而 2 号进程的父进程也是 0 号进程。那么这里的 0,1,2 号进程是什么呢？在系统中有什么作用？</p><h3 id="特殊进程"><a href="#特殊进程" class="headerlink" title="特殊进程"></a>特殊进程</h3><p>0, 1, 2 号进程是 Linux 系统初始化的时候创建的三个进程，初始化的函数在 start_kernel 这里</p><figure class="highlight c"><figcaption><span>init/main.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage __visible <span class="type">void</span> __init __no_sanitize_address <span class="title function_">start_kernel</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *command_line;</span><br><span class="line"><span class="type">char</span> *after_dashes;</span><br><span class="line"></span><br><span class="line">set_task_stack_end_magic(&amp;init_task);</span><br><span class="line">smp_setup_processor_id();</span><br><span class="line">debug_objects_early_init();</span><br><span class="line">init_vmlinux_build_id();</span><br><span class="line"></span><br><span class="line">cgroup_init_early();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...... 省略其它逻辑</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Do the rest non-__init&#x27;ed, we&#x27;re now alive */</span></span><br><span class="line">arch_call_rest_init();</span><br><span class="line"></span><br><span class="line">prevent_tail_call_optimization();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="0-号进程"><a href="#0-号进程" class="headerlink" title="0 号进程"></a>0 号进程</h4><p>通过 <code>init/main.c</code> 的 <code>start_kernel</code> 代码，可以看到有一行 <code>set_task_stack_end_magic(&amp;init_task)</code>，其中 <code>init_task</code> 定义如下：</p><figure class="highlight c"><figcaption><span>init/init_task.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Set up the first task table, touch at your own risk!. Base=0,</span></span><br><span class="line"><span class="comment"> * limit=0x1fffff (=2MB)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> <span class="title">init_task</span></span></span><br></pre></td></tr></table></figure><p>它是系统创建的第一个进程，称为 0 号进程，这是唯一一个没有通过 <code>fork</code> 或者 <code>kernel_thread</code> 产生的进程，是进程列表的第一个。</p><h4 id="1-号进程"><a href="#1-号进程" class="headerlink" title="1 号进程"></a>1 号进程</h4><p>通过 <code>init/main.c</code> 的 <code>start_kernel</code> 代码，可以看到有一行 <code>arch_call_rest_init()</code></p><figure class="highlight c"><figcaption><span>init/main.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init __weak <span class="title function_">arch_call_rest_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">rest_init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">noinline <span class="type">void</span> __ref <span class="title function_">rest_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span></span><br><span class="line"><span class="type">int</span> pid;</span><br><span class="line"></span><br><span class="line">rcu_scheduler_starting();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We need to spawn init first so that it obtains pid 1, however</span></span><br><span class="line"><span class="comment"> * the init task will end up wanting to create kthreads, which, if</span></span><br><span class="line"><span class="comment"> * we schedule it before we create kthreadd, will OOPS.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">pid = user_mode_thread(kernel_init, <span class="literal">NULL</span>, CLONE_FS);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Pin init on the boot CPU. Task migration is not properly working</span></span><br><span class="line"><span class="comment"> * until sched_init_smp() has been run. It will set the allowed</span></span><br><span class="line"><span class="comment"> * CPUs for init to the non isolated CPUs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> rcu_read_lock();</span><br><span class="line">tsk = find_task_by_pid_ns(pid, &amp;init_pid_ns);</span><br><span class="line">tsk-&gt;flags |= PF_NO_SETAFFINITY;</span><br><span class="line">set_cpus_allowed_ptr(tsk, cpumask_of(smp_processor_id()));</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">numa_default_policy();</span><br><span class="line">pid = kernel_thread(kthreadd, <span class="literal">NULL</span>, CLONE_FS | CLONE_FILES);</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>arch_call_rest_init</code> 最终调用了 <code>rest_init</code>，<code>rest_init</code> 第一大工作就是使用 <code>user_mode_thread(kernel_init, NULL, CLONE_FS)</code> 创建第二个进程，这个就是 1 号进程。对于 Linux 操作系统来说，有“划时代”的意义。因为它将运行一个用户进程，这意味着后续的用户进程可以通过这个进程创建，从而形成一颗进程树。可以看到传入的第一个参数 <code>kernel_init</code> 是一个函数</p><figure class="highlight c"><figcaption><span>init/main.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *ramdisk_execute_command = <span class="string">&quot;/init&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __ref <span class="title function_">kernel_init</span><span class="params">(<span class="type">void</span> *unused)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="keyword">if</span> (ramdisk_execute_command) &#123;</span><br><span class="line">ret = run_init_process(ramdisk_execute_command);</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">pr_err(<span class="string">&quot;Failed to execute %s (error %d)\n&quot;</span>,</span><br><span class="line">       ramdisk_execute_command, ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We try each of these until one succeeds.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The Bourne shell can be used instead of init if we are</span></span><br><span class="line"><span class="comment"> * trying to recover a really broken machine.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (execute_command) &#123;</span><br><span class="line">ret = run_init_process(execute_command);</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">panic(<span class="string">&quot;Requested init %s failed (error %d).&quot;</span>,</span><br><span class="line">      execute_command, ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (CONFIG_DEFAULT_INIT[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">ret = run_init_process(CONFIG_DEFAULT_INIT);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">pr_err(<span class="string">&quot;Default init %s failed (error %d)\n&quot;</span>,</span><br><span class="line">       CONFIG_DEFAULT_INIT, ret);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!try_to_run_init_process(<span class="string">&quot;/sbin/init&quot;</span>) ||</span><br><span class="line">    !try_to_run_init_process(<span class="string">&quot;/etc/init&quot;</span>) ||</span><br><span class="line">    !try_to_run_init_process(<span class="string">&quot;/bin/init&quot;</span>) ||</span><br><span class="line">    !try_to_run_init_process(<span class="string">&quot;/bin/sh&quot;</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">panic(<span class="string">&quot;No working init found.  Try passing init= option to kernel. &quot;</span></span><br><span class="line">      <span class="string">&quot;See Linux Documentation/admin-guide/init.rst for guidance.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">run_init_process</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *init_filename)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> *p;</span><br><span class="line"></span><br><span class="line">argv_init[<span class="number">0</span>] = init_filename;</span><br><span class="line">pr_info(<span class="string">&quot;Run %s as init process\n&quot;</span>, init_filename);</span><br><span class="line">pr_debug(<span class="string">&quot;  with arguments:\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (p = argv_init; *p; p++)</span><br><span class="line">pr_debug(<span class="string">&quot;    %s\n&quot;</span>, *p);</span><br><span class="line">pr_debug(<span class="string">&quot;  with environment:\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (p = envp_init; *p; p++)</span><br><span class="line">pr_debug(<span class="string">&quot;    %s\n&quot;</span>, *p);</span><br><span class="line"><span class="keyword">return</span> kernel_execve(init_filename, argv_init, envp_init);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">try_to_run_init_process</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *init_filename)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">ret = run_init_process(init_filename);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret &amp;&amp; ret != -ENOENT) &#123;</span><br><span class="line">pr_err(<span class="string">&quot;Starting init: %s exists but couldn&#x27;t execute it (error %d)\n&quot;</span>,</span><br><span class="line">       init_filename, ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到调用过程，先尝试运行 <code>ramdisk</code> 的 <code>/init</code>，或者普通文件系统上的 <code>/sbin/init</code>, <code>/etc/init</code>, <code>/bin/init</code>, <code>/bin/sh</code>（不同版本的 Linux 会选择不同的文件启动），只要有一个启动起来就行了。</p><p>最终调用的流程:</p><pre><code class="highlight mermaid">flowchart LRkernel_execve --&gt; bprm_execvebprm_execve --&gt; exec_binprmexec_binprm --&gt; search_binary_handlersearch_binary_handler --&gt; load_binary</code></pre><p>可以看到 <code>load_binary</code> 的 ELF 实现就是 <code>load_elf_library</code>，最终调用 <code>start_thread</code></p><figure class="highlight c"><figcaption><span>arch/x86/kernel/process_32.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">start_thread</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs, <span class="type">unsigned</span> <span class="type">long</span> new_ip, <span class="type">unsigned</span> <span class="type">long</span> new_sp)</span></span><br><span class="line">&#123;</span><br><span class="line">loadsegment(gs, <span class="number">0</span>);</span><br><span class="line">regs-&gt;fs= <span class="number">0</span>;</span><br><span class="line">regs-&gt;ds= __USER_DS;</span><br><span class="line">regs-&gt;es= __USER_DS;</span><br><span class="line">regs-&gt;ss= __USER_DS;</span><br><span class="line">regs-&gt;cs= __USER_CS;</span><br><span class="line">regs-&gt;ip= new_ip;</span><br><span class="line">regs-&gt;sp= new_sp;</span><br><span class="line">regs-&gt;flags= X86_EFLAGS_IF;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(start_thread);</span><br></pre></td></tr></table></figure><p>这里的 <code>pt_regs</code> 就是寄存器，这个结构就是在系统调用的时候，内核中保存用户态上下文的，里面将用户态的代码段 CS 设置为 __USER_CS，将用户态的数据段 DS 设置为 __USER_DS，以及指令指针寄存器 IP、栈指针寄存器 SP，这里相当于补上了系统调用里，保存寄存器的步骤。所以这里执行完成之后，就回到用户态了。所以是相当于从内核态执行了 <code>exec</code> 生成了 1 号进程，执行完成后，1 号进程从内核态返回用户态并最终运行在用户态，成为了用户态进程的祖先。</p><h4 id="2-号进程"><a href="#2-号进程" class="headerlink" title="2 号进程"></a>2 号进程</h4><p>通过 <code>init/main.c</code> 的 <code>rest_init</code> 第二个工作就是通过 <code>kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES)</code> 创建 2 号进程，这里的 <code>thread</code> 可以翻译成线程，这也是 Linux 操作系统很重要的一个概念。2 号进程管理所有的内核态的进程，<code>kthreadd</code> 负责所有内核态的线程的调度和管理，是内核态所有线程运行的祖先。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>从用户态来看，进程就是把一个可执行程序启动起来，这个进程包含很多资源，一般一个进程需要有多个模块执行不同或相同的任务，这就叫多线程（Multithreading）。如果只有一个线程，那它就是进程的主线程（一般项目的 main 函数所在的线程）。但是从内核态来看，无论是进程还是线程，都可以统称为任务（Task），都使用相同的数据结构，放在同一个链表中。</p><h3 id="为什么要有线程"><a href="#为什么要有线程" class="headerlink" title="为什么要有线程"></a>为什么要有线程</h3><p>其实对于人一个进程来讲，即便没有主动创建线程，进程也是默认有一个主线程的。线程是负责执行二进制指令的，进程要比线程管的多，除了要执行指令外，内存、文件系统等都需要进程来管理。<strong>进程相当于一个项目，而线程就是为了完成项目需求，而建立的一个个开发任务</strong></p><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><figure class="highlight c"><figcaption><span>thread.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> lock;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mythread</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s: begin\n&quot;</span>, (<span class="type">char</span> *)arg);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">pthread_mutex_lock(&amp;lock);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1e7</span>; i++) &#123;</span><br><span class="line">counter++;</span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;lock);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s: done\n&quot;</span>, (<span class="type">char</span> *)arg);</span><br><span class="line"></span><br><span class="line">pthread_exit((<span class="type">void</span> *)mythread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"><span class="type">pthread_t</span> p1, p2;</span><br><span class="line"><span class="type">int</span> rc;</span><br><span class="line"></span><br><span class="line">rc = pthread_mutex_init(&amp;lock, <span class="literal">NULL</span>); assert(rc == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_attr_t</span> thread_attr;                                        </span><br><span class="line">pthread_attr_init(&amp;thread_attr);                                   </span><br><span class="line">pthread_attr_setdetachstate(&amp;thread_attr, PTHREAD_CREATE_JOINABLE);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;main: begin (counter = %d)\n&quot;</span>, counter);</span><br><span class="line">rc = pthread_create(&amp;p1, &amp;thread_attr, mythread, <span class="string">&quot;A&quot;</span>); assert(rc == <span class="number">0</span>);</span><br><span class="line">rc = pthread_create(&amp;p2, &amp;thread_attr, mythread, <span class="string">&quot;B&quot;</span>); assert(rc == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">pthread_attr_destroy(&amp;thread_attr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// join waits for the threads to finish</span></span><br><span class="line">rc = pthread_join(p1, <span class="literal">NULL</span>); assert(rc == <span class="number">0</span>);</span><br><span class="line">rc = pthread_join(p2, <span class="literal">NULL</span>); assert(rc == <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;main: done with both (counter = %d)\n&quot;</span>, counter);</span><br><span class="line"></span><br><span class="line">pthread_mutex_destroy(&amp;lock);</span><br><span class="line"></span><br><span class="line">pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 pthread 库不是标准 Linux 库，所以需要使用 <code>gcc thread.c -l pthread</code> 来编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@ec2c598cce50 tmp]# gcc thread.c -l pthread</span><br><span class="line">[root@ec2c598cce50 tmp]# ./a.out</span><br><span class="line">main: begin (counter = 0)</span><br><span class="line">B: begin</span><br><span class="line">A: begin</span><br><span class="line">B: done</span><br><span class="line">A: done</span><br><span class="line">main: done with both (counter = 20000000)</span><br></pre></td></tr></table></figure><p>一个普通线程的创建和运行过程:</p><ul><li>声明线程函数<blockquote><p>void *mythread(void *arg) {<br>……<br>pthread_exit((void *)output);<br>}</p></blockquote></li><li>声明线程对象<blockquote><p>pthread_t p1, p2;</p></blockquote></li><li>设置线程属性<blockquote><p>pthread_attr_t thread_attr;<br>pthread_attr_init(&amp;thread_attr);<br>pthread_attr_setdetachstate(&amp;thread_attr, PTHREAD_CREATE_JOINABLE);</p></blockquote></li><li>创建线程<blockquote><p>rc &#x3D; pthread_create(&amp;p1, &amp;thread_attr, mythread, “A”); assert(rc &#x3D;&#x3D; 0);</p></blockquote><ul><li>子线程开始<blockquote><p>void *mythread(void *arg)</p></blockquote></li><li>子线程结束<blockquote><p>pthread_exit</p></blockquote></li></ul></li><li>销毁线程属性<blockquote><p>pthread_attr_destroy(&amp;thread_attr);</p></blockquote></li><li>等待线程结束<blockquote><p>rc &#x3D; pthread_join(p1, NULL); assert(rc &#x3D;&#x3D; 0);</p></blockquote></li><li>主线程结束<blockquote><p>pthread_exit(NULL);</p></blockquote></li></ul><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>线程可以将进程并行起来，加快进度，但是也会带来负面影响，过程并行了，数据应该如何“并行”？</p><h4 id="本地数据"><a href="#本地数据" class="headerlink" title="本地数据"></a>本地数据</h4><p>线程上的本地数据，比如函数执行过程中的局部变量。每个线程都有自己的栈空间，栈的大小可以通过命令 <code>ulimit -a</code> 查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@ec2c598cce50 tmp]# ulimit -a</span><br><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 31345</span><br><span class="line">max locked memory       (kbytes, -l) 64</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 1048576</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) unlimited</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure><p>默认 <code>stack size</code> 大小为 8192（8MB），可以通过 <code>ulimit -s</code> 修改。对于线程栈，可以通过 <code>pthread_attr_t</code> 修改线程栈的大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setstacksize</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">size_t</span> stacksize)</span>;</span><br></pre></td></tr></table></figure><p>主线程在内存中有一个栈空间，其它线程也拥有独立的栈空间。为了避免线程之间的栈空间踩踏，线程栈之间还会有一小块区域，用来隔离保护各自的栈空间。一旦另一个线程踏入到这个隔离区，就会引发段错误(SegmentFault)。</p><p>线程函数调用的压栈过程：</p><p><img data-src="/images/os/linux_process_and_thread/stack.jpeg" alt="函数调用压栈"></p><h4 id="全局数据"><a href="#全局数据" class="headerlink" title="全局数据"></a>全局数据</h4><p>在整个进程里共享的全局数据，例如全局变量，虽然在不同进程中是隔离的，但是在一个进程中是共享的。如果同一个全局变量，两个线程一起修改，那肯定会有问题。这就需要有一种机制来保护顺序，让运行结果可预期。可以通过加锁或者信号量等一些办法来控制。</p><h4 id="私有数据"><a href="#私有数据" class="headerlink" title="私有数据"></a>私有数据</h4><p>可以通过 <code>pthread_key_create</code> 创建</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_key_create</span><span class="params">(<span class="type">pthread_key_t</span> *key, <span class="type">void</span> (*destructor)(<span class="type">void</span>*))</span></span><br></pre></td></tr></table></figure><p>创建一个 key，的同时，会传入一个析构函数（释放资源的时候执行的函数）。key 一旦被创建，所欲呕线程都可以访问它，但各个线程可以根据自己的需要往 key 中填入不同的值，这就相当于提供了一个同名而不同值的全局变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置 key 对应的 value</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setspecific</span><span class="params">(<span class="type">pthread_key_t</span> key, <span class="type">const</span> <span class="type">void</span> *value)</span></span><br><span class="line"><span class="comment">// 获取 key 对应的 value</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">pthread_getspecific</span><span class="params">(<span class="type">pthread_key_t</span> key)</span></span><br></pre></td></tr></table></figure><blockquote><p>在 Linux 里面，无论是进程还是线程，到了内核里面，统一都叫任务（Task），由一个统一的结构体 <code>task_struct</code> 进行管理。接下来将继续学习任务的调度。</p></blockquote><hr><p>参考链接:</p><ul><li><a href="https://mp.weixin.qq.com/s/HFQL5d-C24DKjQbYAQfl8g">https://mp.weixin.qq.com/s/HFQL5d-C24DKjQbYAQfl8g</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247501576&idx=1&sn=657e1c89d1007a935820d394d64f4035&scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz&#x3D;Mzk0MjE3NDE0Ng&#x3D;&#x3D;&amp;mid&#x3D;2247501576&amp;idx&#x3D;1&amp;sn&#x3D;657e1c89d1007a935820d394d64f4035&amp;scene&#x3D;21#wechat_redirect</a></li><li><a href="https://zhuanlan.zhihu.com/p/79772089">https://zhuanlan.zhihu.com/p/79772089</a></li><li><a href="https://www.jianshu.com/p/0d90b92000c0">https://www.jianshu.com/p/0d90b92000c0</a></li><li><a href="https://segmentfault.com/a/1190000039367851?utm_source=sf-similar-article">https://segmentfault.com/a/1190000039367851?utm_source&#x3D;sf-similar-article</a></li><li><a href="https://www.cnblogs.com/chaojiyingxiong/p/15799617.html">https://www.cnblogs.com/chaojiyingxiong/p/15799617.html</a></li><li><a href="http://www.wowotech.net/process_management/scheduler-history.html">http://www.wowotech.net/process_management&#x2F;scheduler-history.html</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-scheduler/index.html">https://www.ibm.com/developerworks/cn/linux/l-cn-scheduler/index.html</a></li><li><a href="https://www.jianshu.com/p/673c9e4817a8">https://www.jianshu.com/p/673c9e4817a8</a></li><li><a href="https://blog.eastonman.com/blog/2021/02/cfs/">https://blog.eastonman.com/blog/2021/02/cfs/</a></li><li><a href="https://www.kernel.org/doc/html/latest/scheduler/sched-design-CFS.html">https://www.kernel.org/doc/html/latest/scheduler/sched-design-CFS.html</a></li><li><a href="https://time.geekbang.org/column/intro/100024701?tab=catalog">https://time.geekbang.org/column/intro/100024701?tab=catalog</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Linux 进程和线程&lt;/p&gt;
&lt;h2 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h2&gt;&lt;p&gt;进程的定义如下:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;进程（Process）是指计算机已执行的程序，用户下达执行进程的命令后，就会产生进程。同一个程序可以产生多个进程（一对多），以允许同时有多个用户执行同一个程序，却不会相互冲突。进程需要一些资源才能完成工作，比如 CPU、内存、存储、文件以及 I&amp;#x2F;O 设备等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里说的程序，一般都是 ELF 格式的可执行文件。&lt;/p&gt;
&lt;h3 id=&quot;ELF&quot;&gt;&lt;a href=&quot;#ELF&quot; class=&quot;headerlink&quot; title=&quot;ELF&quot;&gt;&lt;/a&gt;ELF&lt;/h3&gt;</summary>
    
    
    
    <category term="OS" scheme="http://example.com/categories/OS/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>使用 HEXO 构建 github 博客</title>
    <link href="http://example.com/2022/02/28/other/build-github-blog-with-hexo/"/>
    <id>http://example.com/2022/02/28/other/build-github-blog-with-hexo/</id>
    <published>2022-02-28T01:09:09.000Z</published>
    <updated>2023-05-11T05:53:11.750Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Init-blog"><a href="#Init-blog" class="headerlink" title="Init blog"></a>Init blog</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><h2 id="Themes"><a href="#Themes" class="headerlink" title="Themes"></a>Themes</h2><p>可以在 <a href="https://hexo.io/themes/">这里</a> 查看自己喜欢的主题，我使用的是 <a href="https://github.com/XPoet/hexo-theme-keep">keep</a>, 这个主题(对移动端也进行适配了的)，如果喜欢的话可以根据 <a href="https://keep-docs.xpoet.cn/usage-tutorial/configuration-guide.html">这个配置</a> 配置成你想要的样式</p><h2 id="Github-Setting"><a href="#Github-Setting" class="headerlink" title="Github Setting"></a>Github Setting</h2><p><a href="https://printempw.github.io/use-github-actions-to-deploy-hexo-blog/">使用 Github Actions 自动部署 Hexo 博客</a>, 这个就是我参考的一个文档，其中需要说明的一些点有如下的地方：</p><h3 id="ssh-keygen"><a href="#ssh-keygen" class="headerlink" title="ssh-keygen"></a>ssh-keygen</h3><p><strong>使用 <code>ssh-keygen</code> 生成密钥对的时候不要输入密码</strong></p><h3 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h3><p>最后的 <code>workflow</code> 文件里面的 <code>npm hexo deploy</code> 是需要把项目根目录的 <code>_config.yml</code> 文件里面的 <code>deploy</code> type 修改成这样：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">&#x27;git&#x27;</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">&quot;git@github.com:champly/champly.github.io.git&quot;</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">champly</span></span><br><span class="line">  <span class="attr">email:</span> <span class="string">champly@outlook.com</span></span><br></pre></td></tr></table></figure><p>同时还需要安装 <code>hexo-deployer-git</code>，要不然的话是不支持 <code>git</code> 类型，使用 <code>npm install hexo-deployer-git</code> 进行安装</p><h3 id="themes-config"><a href="#themes-config" class="headerlink" title="themes config"></a>themes config</h3><p><a href="https://github.com/champly/champly.github.io/blob/source/_config.theme.yml">_config.theme.yml</a> 这里面是我的配置，在 <a href="https://github.com/champly/champly.github.io/blob/source/.github/workflows/deploy.yml">workflow</a> 里面是有一个替换配置和导入 <code>images</code> 的过程</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">cp</span> <span class="string">_config.theme.yml</span> <span class="string">themes/keep/_config.yml</span></span><br><span class="line"><span class="string">cp</span> <span class="string">images/*</span> <span class="string">themes/keep/source/images/</span></span><br></pre></td></tr></table></figure><p>这里的主要逻辑就是通过 <code>github actions</code> 自动构建，然后通过配置证书，让 <code>npm deploy</code> 的时候可以直接推送到 <code>main</code> 分支，所以就需要把默认分支配置成 <code>source</code>，展示的分支配置成 <code>main</code>.</p><p>其他的部分在上面的文档里面介绍的比较详细了，可以多看看.</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Init-blog&quot;&gt;&lt;a href=&quot;#Init-blog&quot; class=&quot;headerlink&quot; title=&quot;Init blog&quot;&gt;&lt;/a&gt;Init blog&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-cli -g&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo init blog&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd blog&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;Themes&quot;&gt;&lt;a href=&quot;#Themes&quot; class=&quot;headerlink&quot; title=&quot;Themes&quot;&gt;&lt;/a&gt;Themes&lt;/h2&gt;&lt;p&gt;可以在 &lt;a href=&quot;https://hexo.io/themes/&quot;&gt;这里&lt;/a&gt; 查看自己喜欢的主题，我使用的是 &lt;a href=&quot;https://github.com/XPoet/hexo-theme-keep&quot;&gt;keep&lt;/a&gt;, 这个主题(对移动端也进行适配了的)，如果喜欢的话可以根据 &lt;a href=&quot;https://keep-docs.xpoet.cn/usage-tutorial/configuration-guide.html&quot;&gt;这个配置&lt;/a&gt; 配置成你想要的样式&lt;/p&gt;
&lt;h2 id=&quot;Github-Setting&quot;&gt;&lt;a href=&quot;#Github-Setting&quot; class=&quot;headerlink&quot; title=&quot;Github Setting&quot;&gt;&lt;/a&gt;Github Setting&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://printempw.github.io/use-github-actions-to-deploy-hexo-blog/&quot;&gt;使用 Github Actions 自动部署 Hexo 博客&lt;/a&gt;, 这个就是我参考的一个文档，其中需要说明的一些点有如下的地方：&lt;/p&gt;</summary>
    
    
    
    <category term="Blog" scheme="http://example.com/categories/Blog/"/>
    
    
    <category term="Hexo" scheme="http://example.com/tags/Hexo/"/>
    
    <category term="Next" scheme="http://example.com/tags/Next/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 网络问题排查</title>
    <link href="http://example.com/2019/08/21/network/kubernetes-network-problem/"/>
    <id>http://example.com/2019/08/21/network/kubernetes-network-problem/</id>
    <published>2019-08-21T07:23:09.000Z</published>
    <updated>2023-05-11T05:53:11.750Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安全组"><a href="#安全组" class="headerlink" title="安全组"></a>安全组</h2><p>当一个网络包进入网卡的时候，首先拿下 <code>mac</code> 头看看是不是当前网卡的。</p><ol><li>如果是，则拿下 <code>IP</code> 头，得到了 <code>IP</code> 之后，就开始进行路由判断。在路由判断之前这个节点称为 <code>PREROUTING</code>。</li><li>如果发现ip是当前网卡 <code>IP</code>，包就应该发给上面的传输层，这个节点叫做 <code>INPUT</code>。</li><li>如果发现 <code>IP</code> 不是当前网卡的，就需要进行转发，这个节点就叫 <code>FORWARD</code>。</li><li>如果ip是当前网卡的 <code>IP</code>，则发送到上层处理。处理完一般会返回一个结果，把处理结果发出去，这个节点称为 <code>OUTPUT</code>。</li><li>无论是 <code>FORWARD</code> 和 <code>OUTPUT</code>，都是在路由判断之后发生的，最有一个节点是 <code>POSTROUTING</code>。</li></ol><h2 id="iptables-模块"><a href="#iptables-模块" class="headerlink" title="iptables 模块"></a><code>iptables</code> 模块</h2><p>在 <code>Linux</code> 内核中，有一个框架叫 <code>Netfilter</code>。可以在上面的几个节点放一个hook函数，这些函数可以对数据包进行干预。如果接受就是 <code>ACCEPT</code>;如果需要过滤掉就是 <code>DROP</code>;如果需要发送给用户态进程处理，就是 <code>QUEUE</code>。</p><p><code>iptables</code> 就是实现了 <code>Netfilter</code> 框架，在上面五个节点上都放了hook函数，按照功能可以分为:</p><ol><li>conntrack: 连接跟踪</li><li>filter: 数据包过滤</li><li>nat: 网络地址转换</li><li>mangle: 数据包修改</li></ol><h2 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h2><p>在用户态，有一个客户端程序 <code>iptables</code>,用命令行来干预内核的规则,内核的功能对于 <code>iptables</code> 来说，就是表和链的概念。</p><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><ul><li>raw</li><li>mangle</li><li>nat</li><li>filter</li></ul><p>优先级: <code>raw</code> &gt; <code>mangle</code> &gt; <code>nat</code> &gt; <code>filter</code></p><p>raw 不常用，主要功能都在剩下的几个表里面</p><h4 id="filter-表"><a href="#filter-表" class="headerlink" title="filter 表"></a><code>filter</code> 表</h4><p>处理过滤功能</p><ul><li><code>INPUT</code> 链: 过滤所有目标地址是本机的数据包</li><li><code>FORWARD</code> 链: 过滤所有路过本机的数据包</li><li><code>OUTPUT</code> 链: 过滤所有由本机产生的数据包</li></ul><h4 id="nat-表"><a href="#nat-表" class="headerlink" title="nat 表"></a><code>nat</code> 表</h4><ul><li><code>PREROUTING</code> 链: 可以在数据包到达防火墙之前改变目标地址(DNT)</li><li><code>OUTPUT</code> 链: 可以改变本地产生的数据包的目标地址</li><li><code>POSTROUTING</code> 链: 在数据包离开防火墙时改变数据包的源地址(SNAT)</li></ul><h4 id="mangle-表"><a href="#mangle-表" class="headerlink" title="mangle 表"></a><code>mangle</code> 表</h4><ul><li><code>PREROUTING</code> 链</li><li><code>INPUT</code> 链</li><li><code>FORWARD</code> 链</li><li><code>OUTPUT</code> 链</li><li><code>POSTROUTING</code> 链</li></ul><h4 id="raw-表"><a href="#raw-表" class="headerlink" title="raw 表"></a><code>raw</code> 表</h4><ul><li><code>PREROUTING</code> 链</li><li><code>OUTPUT</code> 链</li></ul><p>将 <code>iptables</code> 的表和链整合起来就形成了下面的图和过程。</p><p><img data-src="/images/network/kubernetes-network-problem/iptables.png" alt="iptables"></p><h2 id="Kubernetes-里的-Service"><a href="#Kubernetes-里的-Service" class="headerlink" title="Kubernetes 里的 Service"></a><code>Kubernetes</code> 里的 <code>Service</code></h2><p>** <code>Service</code> 是由 <code>kube-proxy</code> 组件加上 <code>iptables</code> 来共同实现的**</p><h3 id="iptables-模式"><a href="#iptables-模式" class="headerlink" title="iptables 模式"></a><code>iptables</code> 模式</h3><p>当我们创建的 <code>service</code> 提交到 <code>Kubernetes</code> 的时候，<code>kube-proxy</code> 就可以通过 <code>Service</code> 的 <code>Informer</code> 感知到 <code>Service</code> 对象添加。从而对这个事件进行响应，它会在宿主机上创建一条 <code>iptables</code> 规则。可以使用 <code>iptables-save</code> 看见这样一条规则:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A KUBE-SERVICES -d 10.27.248.11/32 -p tcp -m comment --comment &quot;default/hostnames: cluster IP&quot; -m tcp --dport 80 -j KUBE-SVC-NWV5X2332I4OT4T3</span><br></pre></td></tr></table></figure><p>凡是目的地址是 <code>10.27.248.11</code>,端口号是80的包,都使用 <code>KUBE-SVC-NWV5X2332I4OT4T3</code> <code>iptables</code> 链处理，而这个 <code>10.27.248.11</code> 这个就是 <code>Service</code> 的 <code>clusterIP</code>，在查看 <code>KUBE-SVC-NWV5X2332I4OT4T3</code> 规则，实际上是一组规则集合:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-A KUBE-SVC-NWV5X2332I4OT4T3 -m comment --comment &quot;default/hostnames:&quot; -m statistic --mode random --probability 0.33332999982 -j KUBE-SEP-WNBA2IHDGP2BOBGZ</span><br><span class="line">-A KUBE-SVC-NWV5X2332I4OT4T3 -m comment --comment &quot;default/hostnames:&quot; -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-X3P2623AGDH6CDF3</span><br><span class="line">-A KUBE-SVC-NWV5X2332I4OT4T3 -m comment --comment &quot;default/hostnames:&quot; -j KUBE-SEP-57KPRZ3JQVENLNBR</span><br></pre></td></tr></table></figure><p>这实际上是一组随机模式(–mode random)的 <code>iptables</code> 链,而 <code>KUBE-SEP-(hash)</code> 链指向的最终地址就是代理的三个 <code>Pod</code>(就是 <code>Endpoint</code>)。所以这一组规则就是 <code>Service</code> 实现负载均衡的位置。查看上述三条链明细,就能理解 <code>Service</code> 转发的具体原理：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-A KUBE-SEP-57KPRZ3JQVENLNBR -s 10.28.1.123/32 -m comment --comment &quot;default/hostnames:&quot; -j MARK --set-xmark 0x00004000/0x00004000</span><br><span class="line">-A KUBE-SEP-57KPRZ3JQVENLNBR -p tcp -m comment --comment &quot;default/hostnames:&quot; -m tcp -j DNAT --to-destination 10.28.1.123:8080</span><br><span class="line"></span><br><span class="line">-A KUBE-SEP-WNBA2IHDGP2BOBGZ -s 10.28.1.22/32 -m comment --comment &quot;default/hostnames:&quot; -j MARK --set-xmark 0x00004000/0x00004000</span><br><span class="line">-A KUBE-SEP-WNBA2IHDGP2BOBGZ -p tcp -m comment --comment &quot;default/hostnames:&quot; -m tcp -j DNAT --to-destination 10.28.1.22:8080</span><br><span class="line"></span><br><span class="line">-A KUBE-SEP-X3P2623AGDH6CDF3 -s 10.28.3.11/32 -m comment --comment &quot;default/hostnames:&quot; -j MARK --set-xmark 0x00004000/0x00004000</span><br><span class="line">-A KUBE-SEP-X3P2623AGDH6CDF3 -p tcp -m comment --comment &quot;default/hostnames:&quot; -m tcp -j DNAT --to-destination 10.28.3.11:8080</span><br></pre></td></tr></table></figure><p>这三条链其实就是三条 <code>DNAT</code> 规则。<code>iptables</code> 对流入的 <code>IP</code> 包还设置了一个标志(<code>--set-xmark</code>)，在 <code>PREROUTING</code> 检查之前将流入 <code>IP</code> 包的目的地址和端口改成 <code>--to-destination</code> 所指定的新的地址和端口</p><h3 id="IPVS-模式"><a href="#IPVS-模式" class="headerlink" title="IPVS 模式"></a><code>IPVS</code> 模式</h3><p>基于 <code>iptables</code> 的 <code>Service</code> 实现，都是制约 <code>Kubernetes</code> 项目承载更多量级 <code>Pod</code> 的主要障碍，<code>IPVS</code> 并不需要在主机上为每个 <code>Pod</code> 设置 <code>iptables</code> 规则，而是把这些规则放到了内核态，从而极大地降低了维护这些规则的代价。<code>IPVS</code> 模式的工作原理，和 <code>iptables</code> 类似。当创建了 <code>Service</code> 后，<code>kube-proxy</code> 首先会在宿主机上创建一个虚拟网卡 <code>kube-ipvs0</code>。并为他分配 <code>Service VIP</code> 作为 <code>IP</code> 地址:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ip addr</span></span><br><span class="line">  ...</span><br><span class="line">  73：kube-ipvs0：&lt;BROADCAST,NOARP&gt;  mtu 1500 qdisc noop state DOWN qlen 1000</span><br><span class="line">  link/ether  1a:ce:f5:5f:c1:4d brd ff:ff:ff:ff:ff:ff</span><br><span class="line">  inet 10.27.248.11/32  scope global kube-ipvs0</span><br><span class="line">  valid_lft forever  preferred_lft forever</span><br></pre></td></tr></table></figure><p>然后 <code>kube-proxy</code> 就会通过 <code>Linux</code> 的 <code>IPVS</code> 模块，为这个IP地址设置三个 <code>IPVS</code> 虚拟主机，可以通过 <code>ipvsadm</code> 查看:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ipvsadm -<span class="built_in">ln</span></span></span><br><span class="line"> IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">  Prot LocalAddress:Port Scheduler Flags</span><br><span class="line">    -&gt;  RemoteAddress:Port           Forward  Weight ActiveConn InActConn     </span><br><span class="line">  TCP  10.27.248.11:80 rr</span><br><span class="line">    -&gt;  10.28.1.123:8080   Masq    1       0          0         </span><br><span class="line">    -&gt;  10.28.1.22:8080    Masq    1       0          0</span><br><span class="line">    -&gt;  10.28.3.11:8080    Masq    1       0          0</span><br></pre></td></tr></table></figure><p>这三个 <code>IPVS</code> 虚拟主机的 <code>IP</code> 地址和端口对应的就是被代理的 <code>Pod</code>，之间使用轮询模式(rr)来作为负载均衡。</p><p><em><code>IPVS</code> 模块只负责负载均衡和代理功能，而一个完整的 <code>Service</code> 流程正常工作需要的包过滤，<code>SNAT</code>，<code>DNAT</code> 等操作，还是要靠 <code>iptables</code> 来实现。只不过这些辅助性的 <code>iptables</code> 规则数量有限，也不会随着 <code>Pod</code> 数量增加而增加</em></p><p>查看 <code>iptables</code> <code>nat</code> 表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-A PREROUTING -m comment --comment &quot;kubernetes service portals&quot; -j KUBE-SERVICES</span><br><span class="line">-A OUTPUT -m comment --comment &quot;kubernetes service portals&quot; -j KUBE-SERVICES</span><br><span class="line">-A POSTROUTING -m comment --comment &quot;kubernetes postrouting rules&quot; -j KUBE-POSTROUTING</span><br><span class="line">-A KUBE-FIREWALL -j KUBE-MARK-DROP</span><br><span class="line">-A KUBE-LOAD-BALANCER -j KUBE-MARK-MASQ</span><br><span class="line">-A KUBE-MARK-MASQ -j MARK --set-xmark 0x4000/0x4000</span><br><span class="line">-A KUBE-NODE-PORT -p tcp -m comment --comment &quot;Kubernetes nodeport TCP port for masquerade purpose&quot; -m set --match-set KUBE-NODE-PORT-TCP dst -j KUBE-MARK-MASQ</span><br><span class="line">-A KUBE-POSTROUTING -m comment --comment &quot;kubernetes service traffic requiring SNAT&quot; -m mark --mark 0x4000/0x4000 -j MASQUERADE</span><br><span class="line">-A KUBE-POSTROUTING -m comment --comment &quot;Kubernetes endpoints dst ip:port, source ip for solving hairpin purpose&quot; -m set --match-set KUBE-LOOP-BACK dst,dst,src -j MASQUERADE</span><br><span class="line">-A KUBE-SERVICES ! -s 10.27.248.0/22 -m comment --comment &quot;Kubernetes service cluster ip + port for masquerade purpose&quot; -m set --match-set KUBE-CLUSTER-IP dst,dst -j KUBE-MARK-MASQ</span><br><span class="line">-A KUBE-SERVICES -m addrtype --dst-type LOCAL -j KUBE-NODE-PORT</span><br><span class="line">-A KUBE-SERVICES -m set --match-set KUBE-CLUSTER-IP dst,dst -j ACCEPT</span><br></pre></td></tr></table></figure><p>倒数第 <code>3</code> 条规则表示来源 <code>IP</code> 不是 <code>10.27.248.0/22</code>，则进入 <code>KUBE-MARK-MASQ</code>，打上 <code>0x4000</code> 标。倒数第 <code>5</code> 条规则就是在 <code>POSTROUTING</code> 的时候做 <code>SNAT</code>,如果看到有 <code>0x4000</code> 这个标志的，就修改来源 <code>IP</code>(<code>MASQUERADE</code>)。</p><p><em><code>SNAT</code> 需要指定一个或多个 <code>IP</code>，<code>MASQUERADE</code> 不需要指定，直接获取网卡的 <code>IP</code> 作为来源 <code>IP</code></em></p><h2 id="问题和解决思路"><a href="#问题和解决思路" class="headerlink" title="问题和解决思路"></a>问题和解决思路</h2><h3 id="Service-没办法通过-DNS-访问"><a href="#Service-没办法通过-DNS-访问" class="headerlink" title="Service 没办法通过 DNS 访问"></a><code>Service</code> 没办法通过 <code>DNS</code> 访问</h3><p>区分到底是 <code>Service</code> 本身的配置问题还是集群的 <code>DNS</code> 除了问题，检查的有效方式就是 <code>Kubernetes</code> 自己的 <code>master</code> 节点的 <code>Service</code> <code>DNS</code> 是否正常:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在pod里面执行</span></span><br><span class="line">nslookup kubernetes.default</span><br></pre></td></tr></table></figure><p>如果执行有问题，那么就应该检查 <code>kube-dns</code> 的运行状态和日志。否则的话就应该检查 <code>Service</code> 定义是不是有问题。</p><h3 id="Service-没办法通过-ClusterIP-访问"><a href="#Service-没办法通过-ClusterIP-访问" class="headerlink" title="Service 没办法通过 ClusterIP 访问"></a><code>Service</code> 没办法通过 <code>ClusterIP</code> 访问</h3><p>首先查看时候有 <code>Endpoint</code>(<code>kubectl get endpoint xxxx</code>)，如果 <code>Pod</code> 的 <code>readniessProbe</code> 没有通过,也不会出现在 <code>Endpoint</code> 列表里面。如果 <code>Endpoint</code> 正常，就需要确认一下 <code>kube-proxy</code> 是否正确运行。如果 <code>kube-proxy</code> 一切正常,就应该查看宿主机的 <code>iptables</code>。</p><p><code>iptables</code> 模式的话检查:</p><ul><li><code>KUBE-SERVICE</code> 或者 <code>KUBE-NODEPORTS</code> 规则对应的入口链，这个规则应该和 <code>VIP</code> 和 <code>Service</code> 端口一一对应</li><li><code>KUBE-SEP-(hash)</code> 规则对应的 <code>DNAT</code> 链,和 <code>Endpoint</code> 一一对应</li><li><code>KUBE-SVC-(hash)</code> 规则对应负载均衡链，这些规则的数目应该和 <code>Endpoint</code> 数目对应</li><li>如果是 <code>NodePort</code> 模式的话，还有 <code>POSTROUTING</code> 的 <code>SNAT</code> 链</li></ul><h3 id="Pod-没办法通过-Service-访问自己"><a href="#Pod-没办法通过-Service-访问自己" class="headerlink" title="Pod 没办法通过 Service 访问自己"></a><code>Pod</code> 没办法通过 <code>Service</code> 访问自己</h3><p>这往往就是因为 <code>kubelet</code> 的 <code>hairpin-mode</code> 没有正确被设置(Haripin Mode 发夹模式，在默认情况下，网桥设备是不允许一个数据包从一个端口进来，再从这个端口发出去，开启这个模式从而取消这个限制)</p><h2 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h2><p>使用 <code>nsenter</code> 来进入 <code>Pod</code> 容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function e() &#123;</span><br><span class="line">    set -u</span><br><span class="line">    ns=$&#123;2-&quot;default&quot;&#125;</span><br><span class="line">    container_id=`kubectl -n $ns describe pod $1 | grep -Eo &#x27;docker://.*$&#x27; | head -n 1 | awk -F &#x27;//&#x27; &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">    if [ &quot;$container_id&quot; != &quot;&quot; ]</span><br><span class="line">    then</span><br><span class="line">        echo &quot;container_id:$container_id&quot;</span><br><span class="line"></span><br><span class="line">        pid=`docker inspect -f &#123;&#123;.State.Pid&#125;&#125; $container_id`</span><br><span class="line">        echo &quot;pid:$pid&quot;</span><br><span class="line"></span><br><span class="line">        echo &quot;enter pod netns successfully for $ns/$1&quot;</span><br><span class="line">        nsenter -n --target $pid</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在需要调试的 <code>Pod</code> 的宿主机上先执行这个命令，然后使用 <code>e pod-name namespaces</code> 来进入 <code>Pod</code> 进行调试</p><h2 id="真实案例复盘"><a href="#真实案例复盘" class="headerlink" title="真实案例复盘"></a>真实案例复盘</h2><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>在集群内任意一个节点上访问 <code>Service</code> 的 <code>cluster ip</code>，如果这个 <code>Service</code> 的 <code>Pod</code> 运行在当前节点，则能访问成功，否则访问不成功</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>在运行有 <code>Pod</code> 的宿主机上使用 <code>tcpdump</code> 抓 <code>cni0</code> 的包(<code>cni0</code> 和 <code>eth0</code> 做了桥接)，发现包正常请求，正常返回</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tcpdump -nn -i cni0 tcp and host 10.28.248.11</span></span><br></pre></td></tr></table></figure><p>分析：服务端是正常处理了请求的，应该是在返回的时候包被丢弃了(因为没有返回结果)。通过上面的 <code>IPVS</code> 模式的介绍，查看 <code>iptables</code> 的配置，发现了问题：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pod ClusterCIDR: 10.28.0.0/16</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ServiceCIDR: 10.28.0.0/16</span></span><br></pre></td></tr></table></figure><p>而 <code>iptables</code> 处理的是非 <code>10.28.0.0/16</code> 的包才进行 <code>SNAT</code>，所以导致包回不去，被丢弃了。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ul><li>修改 <code>ServiceCIDR</code> 为另外一个网段(推荐)</li><li>每个宿主机上手动添加一条规则: <code>iptables -t nat -A POSTROUTING -s 10.28.0.0/16 -j SNAT --to-source 10.28.252.241(node ip)</code></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;安全组&quot;&gt;&lt;a href=&quot;#安全组&quot; class=&quot;headerlink&quot; title=&quot;安全组&quot;&gt;&lt;/a&gt;安全组&lt;/h2&gt;&lt;p&gt;当一个网络包进入网卡的时候，首先拿下 &lt;code&gt;mac&lt;/code&gt; 头看看是不是当前网卡的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果是，则拿下 &lt;code&gt;IP&lt;/code&gt; 头，得到了 &lt;code&gt;IP&lt;/code&gt; 之后，就开始进行路由判断。在路由判断之前这个节点称为 &lt;code&gt;PREROUTING&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果发现ip是当前网卡 &lt;code&gt;IP&lt;/code&gt;，包就应该发给上面的传输层，这个节点叫做 &lt;code&gt;INPUT&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果发现 &lt;code&gt;IP&lt;/code&gt; 不是当前网卡的，就需要进行转发，这个节点就叫 &lt;code&gt;FORWARD&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果ip是当前网卡的 &lt;code&gt;IP&lt;/code&gt;，则发送到上层处理。处理完一般会返回一个结果，把处理结果发出去，这个节点称为 &lt;code&gt;OUTPUT&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;无论是 &lt;code&gt;FORWARD&lt;/code&gt; 和 &lt;code&gt;OUTPUT&lt;/code&gt;，都是在路由判断之后发生的，最有一个节点是 &lt;code&gt;POSTROUTING&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;iptables-模块&quot;&gt;&lt;a href=&quot;#iptables-模块&quot; class=&quot;headerlink&quot; title=&quot;iptables 模块&quot;&gt;&lt;/a&gt;&lt;code&gt;iptables&lt;/code&gt; 模块&lt;/h2&gt;&lt;p&gt;在 &lt;code&gt;Linux&lt;/code&gt; 内核中，有一个框架叫 &lt;code&gt;Netfilter&lt;/code&gt;。可以在上面的几个节点放一个hook函数，这些函数可以对数据包进行干预。如果接受就是 &lt;code&gt;ACCEPT&lt;/code&gt;;如果需要过滤掉就是 &lt;code&gt;DROP&lt;/code&gt;;如果需要发送给用户态进程处理，就是 &lt;code&gt;QUEUE&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;iptables&lt;/code&gt; 就是实现了 &lt;code&gt;Netfilter&lt;/code&gt; 框架，在上面五个节点上都放了hook函数，按照功能可以分为:&lt;/p&gt;</summary>
    
    
    
    <category term="CloudNative" scheme="http://example.com/categories/CloudNative/"/>
    
    
    <category term="Kubernetes" scheme="http://example.com/tags/Kubernetes/"/>
    
    <category term="IPVS" scheme="http://example.com/tags/IPVS/"/>
    
    <category term="iptables" scheme="http://example.com/tags/iptables/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes cni 网络插件调试</title>
    <link href="http://example.com/2019/07/29/network/kubernetes-cni-debug/"/>
    <id>http://example.com/2019/07/29/network/kubernetes-cni-debug/</id>
    <published>2019-07-29T06:46:00.000Z</published>
    <updated>2023-05-11T05:53:11.750Z</updated>
    
    <content type="html"><![CDATA[<p>最近搭建 <code>Kubernetes</code> 集群的时候使用的网络插件是 <code>bridge</code> + <code>host-local</code></p><h2 id="关于cni插件"><a href="#关于cni插件" class="headerlink" title="关于cni插件"></a>关于cni插件</h2><p>安装 <code>kubelet</code> 的时候会有一个 <code>kubernetes-cni-version-0.x86_64.rpm</code> 的依赖文件，安装了之后会在 <code>/opt/cni/bin</code> 下面会有各种网络插件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rpm -qpl kubernetes-cni-0.7.5-0.x86_64.rpm</span></span><br><span class="line">warning: kubernetes-cni-0.7.5-0.x86_64.rpm: Header V4 RSA/SHA512 Signature, key ID 3e1ba8d5: NOKEY</span><br><span class="line">/opt/cni</span><br><span class="line">/opt/cni/bin</span><br><span class="line">/opt/cni/bin/bridge</span><br><span class="line">/opt/cni/bin/dhcp</span><br><span class="line">/opt/cni/bin/flannel</span><br><span class="line">/opt/cni/bin/host-device</span><br><span class="line">/opt/cni/bin/host-local</span><br><span class="line">/opt/cni/bin/ipvlan</span><br><span class="line">/opt/cni/bin/loopback</span><br><span class="line">/opt/cni/bin/macvlan</span><br><span class="line">/opt/cni/bin/portmap</span><br><span class="line">/opt/cni/bin/ptp</span><br><span class="line">/opt/cni/bin/sample</span><br><span class="line">/opt/cni/bin/tuning</span><br><span class="line">/opt/cni/bin/vlan</span><br></pre></td></tr></table></figure><p>所有的 <code>cni</code> 插件在 <code>spec-v0.3.1</code> 之前只实现两个接口 <code>add</code>, <code>del</code>。在 <code>spec-v0.4.0</code> 之后会在 <code>del</code> 之前执行 <code>check</code> ,所以多了一个 <code>check</code> 接口。</p><p>版本差异: <a href="https://github.com/containernetworking/cni/blob/master/SPEC.md">Container Network Interface Specification</a></p><h2 id="配置文件使用的-cni-版本"><a href="#配置文件使用的-cni-版本" class="headerlink" title="配置文件使用的 cni 版本"></a>配置文件使用的 <code>cni</code> 版本</h2><p><code>cni</code> 插件使用的插件配置地址 <code>/etc/cni/net.d/</code> 下面的文件，根据排序取第一个配置文件信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /etc/cni/net.d/cni.conf</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;cniVersion&quot;</span>: <span class="string">&quot;0.3.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;mynet&quot;</span>,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;bridge&quot;</span>,</span><br><span class="line">    <span class="string">&quot;bridge&quot;</span>: <span class="string">&quot;cni0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;isDefaultGateway&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;forceAddress&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&quot;ipMasq&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;hairpinMode&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;ipam&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;host-local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ranges&quot;</span>: [</span><br><span class="line">            [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;subnet&quot;</span>: <span class="string">&quot;10.13.0.0/22&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;rangeStart&quot;</span>: <span class="string">&quot;10.13.3.8&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;rangeEnd&quot;</span>: <span class="string">&quot;10.13.3.253&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;gateway&quot;</span>: <span class="string">&quot;10.13.3.254&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;routes&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;dst&quot;</span>: <span class="string">&quot;0.0.0.0/0&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;dataDir&quot;</span>: <span class="string">&quot;/opt/data/cni&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置具体信息可以查看 <a href="https://github.com/containernetworking/plugins/tree/master/plugins">源码plugins里面的插件README.md</a></p><p>比如我们使用的 <code>host-local</code>，我需要知道 <code>cni</code> 版本怎么查看呢？</p><h3 id="查看安装的-kubernetes-cni-版本"><a href="#查看安装的-kubernetes-cni-版本" class="headerlink" title="查看安装的 kubernetes-cni 版本"></a>查看安装的 <code>kubernetes-cni</code> 版本</h3><p>安装的时候知道是 <code>kubernetes-cni-0.7.5-0.x86_64.rpm</code>，所以对应的版本信息是 <code>0.7.5</code></p><h3 id="查看源码-host-local-注册的版本信息"><a href="#查看源码-host-local-注册的版本信息" class="headerlink" title="查看源码 host-local 注册的版本信息"></a>查看源码 <code>host-local</code> 注册的版本信息</h3><p>选择 <code>plugin</code> 插件版本是 <code>0.7.5</code>，查看 <code>host-local</code> 注册信息 <a href="https://github.com/containernetworking/plugins/blob/v0.7.5/plugins/ipam/host-local/main.go">源码</a></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">skel.PluginMain(cmdAdd, cmdDel, version.All)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到版本是All</p><h3 id="查看-plugin-使用的-cni-版本"><a href="#查看-plugin-使用的-cni-版本" class="headerlink" title="查看 plugin 使用的 cni 版本"></a>查看 <code>plugin</code> 使用的 <code>cni</code> 版本</h3><p>同上一步，选择源码文件的提交 <code>tag</code> 为 <code>0.7.5</code>，查看 <code>plugins</code> 使用的 <code>cni</code> 版本信息 <a href="https://github.com/containernetworking/plugins/blob/v0.7.5/vendor/github.com/containernetworking/cni/pkg/version/version.go">源码</a></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Legacy PluginInfo describes a plugin that is backwards compatible with the</span></span><br><span class="line"><span class="comment">// CNI spec version 0.1.0.  In particular, a runtime compiled against the 0.1.0</span></span><br><span class="line"><span class="comment">// library ought to work correctly with a plugin that reports support for</span></span><br><span class="line"><span class="comment">// Legacy versions.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Any future CNI spec versions which meet this definition should be added to</span></span><br><span class="line"><span class="comment">// this list.</span></span><br><span class="line"><span class="keyword">var</span> Legacy = PluginSupports(<span class="string">&quot;0.1.0&quot;</span>, <span class="string">&quot;0.2.0&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> All = PluginSupports(<span class="string">&quot;0.1.0&quot;</span>, <span class="string">&quot;0.2.0&quot;</span>, <span class="string">&quot;0.3.0&quot;</span>, <span class="string">&quot;0.3.1&quot;</span>)</span><br></pre></td></tr></table></figure><p>可以看到All对应的版本信息支持 “0.1.0”, “0.2.0”, “0.3.0”, “0.3.1”,所以我就可以写 <code>0.3.1</code> 了</p><h2 id="调试-cni"><a href="#调试-cni" class="headerlink" title="调试 cni"></a>调试 <code>cni</code></h2><p>在上面我们的 <code>cni</code> 版本是 <code>0.3.1</code>,所以在查看 <a href="https://github.com/containernetworking/cni">源码</a> 的时候选择 spec-v0.3.1</p><p>在 <code>README.md</code> 里面有测试方法</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ CNI_PATH=<span class="variable">$GOPATH</span>/src/github.com/containernetworking/plugins/bin</span><br><span class="line">$ <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/containernetworking/cni/scripts</span><br><span class="line">$ sudo CNI_PATH=<span class="variable">$CNI_PATH</span> ./priv-net-run.sh ifconfig</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr f2:c2:6f:54:b8:2b  </span><br><span class="line">          inet addr:10.22.0.2  Bcast:0.0.0.0  Mask:255.255.0.0</span><br><span class="line">          inet6 addr: fe80::f0c2:6fff:fe54:b82b/64 Scope:Link</span><br><span class="line">          UP BROADCAST MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:1 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:1 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:90 (90.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br></pre></td></tr></table></figure><p>其中我们只需要使用到 <code>scripts</code> 下面的 <code>priv-net-run.sh</code> 和 <code>exec-plugins.sh</code> 这两个文件</p><p>把这两个文件下载到本地，然后添加可执行权限</p><p>添加 <code>/etc/cni/net.d/</code> 下面的 <code>cni</code> 配置，添加 <code>CNI_PATH</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@10 tmp]<span class="comment"># export CNI_PATH=/opt/cni/bin/</span></span><br><span class="line">[root@10 tmp]<span class="comment"># ./priv-net-run.sh</span></span><br></pre></td></tr></table></figure><p>其中 <code>/opt/cni/bin</code> 就是 <code>kubernetes-cni-0.7.5-0.x86_64.rpm</code> 对应的插件目录，如果没有修改就是用这个就可以了</p><p>可以修改 <code>shell</code> 脚本来调试 <code>cni</code> 插件，比如我下面修改之后可以看到执行过程</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">[root@10 tmp]<span class="comment"># ./priv-net-run.sh</span></span><br><span class="line">add 7ac145c133dc63c2 /var/run/netns/7ac145c133dc63c2</span><br><span class="line">netconf:/etc/cni/net.d/cni.conf</span><br><span class="line">name:mynet</span><br><span class="line">plugin:bridge</span><br><span class="line">res:&#123;</span><br><span class="line">    <span class="string">&quot;cniVersion&quot;</span>: <span class="string">&quot;0.3.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;interfaces&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;cni0&quot;</span>,</span><br><span class="line">            <span class="string">&quot;mac&quot;</span>: <span class="string">&quot;76:02:71:5b:9c:79&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;vetheb50e2bb&quot;</span>,</span><br><span class="line">            <span class="string">&quot;mac&quot;</span>: <span class="string">&quot;76:02:71:5b:9c:79&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;eth0&quot;</span>,</span><br><span class="line">            <span class="string">&quot;mac&quot;</span>: <span class="string">&quot;ce:bf:1f:fc:ff:d1&quot;</span>,</span><br><span class="line">            <span class="string">&quot;sandbox&quot;</span>: <span class="string">&quot;/var/run/netns/7ac145c133dc63c2&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;ips&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;version&quot;</span>: <span class="string">&quot;4&quot;</span>,</span><br><span class="line">            <span class="string">&quot;interface&quot;</span>: 2,</span><br><span class="line">            <span class="string">&quot;address&quot;</span>: <span class="string">&quot;10.13.3.23/22&quot;</span>,</span><br><span class="line">            <span class="string">&quot;gateway&quot;</span>: <span class="string">&quot;10.13.3.254&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;routes&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;dst&quot;</span>: <span class="string">&quot;0.0.0.0/0&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;dst&quot;</span>: <span class="string">&quot;0.0.0.0/0&quot;</span>,</span><br><span class="line">            <span class="string">&quot;gw&quot;</span>: <span class="string">&quot;10.13.3.254&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;dns&quot;</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">No <span class="built_in">command</span> specified</span><br><span class="line">del 7ac145c133dc63c2 /var/run/netns/7ac145c133dc63c2</span><br><span class="line">netconf:/etc/cni/net.d/cni.conf</span><br><span class="line">name:mynet</span><br><span class="line">plugin:bridge</span><br><span class="line">res:</span><br></pre></td></tr></table></figure><hr><p>参考资料:</p><ul><li><a href="https://segmentfault.com/a/1190000017182169">浅谈k8s cni 插件</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近搭建 &lt;code&gt;Kubernetes&lt;/code&gt; 集群的时候使用的网络插件是 &lt;code&gt;bridge&lt;/code&gt; + &lt;code&gt;host-local&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;关于cni插件&quot;&gt;&lt;a href=&quot;#关于cni插件&quot; class=&quot;headerlink&quot; title=&quot;关于cni插件&quot;&gt;&lt;/a&gt;关于cni插件&lt;/h2&gt;&lt;p&gt;安装 &lt;code&gt;kubelet&lt;/code&gt; 的时候会有一个 &lt;code&gt;kubernetes-cni-version-0.x86_64.rpm&lt;/code&gt; 的依赖文件，安装了之后会在 &lt;code&gt;/opt/cni/bin&lt;/code&gt; 下面会有各种网络插件&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# rpm -qpl kubernetes-cni-0.7.5-0.x86_64.rpm&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;warning: kubernetes-cni-0.7.5-0.x86_64.rpm: Header V4 RSA/SHA512 Signature, key ID 3e1ba8d5: NOKEY&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/opt/cni&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/opt/cni/bin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/opt/cni/bin/bridge&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/opt/cni/bin/dhcp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/opt/cni/bin/flannel&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/opt/cni/bin/host-device&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/opt/cni/bin/host-local&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/opt/cni/bin/ipvlan&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/opt/cni/bin/loopback&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/opt/cni/bin/macvlan&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/opt/cni/bin/portmap&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/opt/cni/bin/ptp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/opt/cni/bin/sample&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/opt/cni/bin/tuning&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/opt/cni/bin/vlan&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;所有的 &lt;code&gt;cni&lt;/code&gt; 插件在 &lt;code&gt;spec-v0.3.1&lt;/code&gt; 之前只实现两个接口 &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;del&lt;/code&gt;。在 &lt;code&gt;spec-v0.4.0&lt;/code&gt; 之后会在 &lt;code&gt;del&lt;/code&gt; 之前执行 &lt;code&gt;check&lt;/code&gt; ,所以多了一个 &lt;code&gt;check&lt;/code&gt; 接口。&lt;/p&gt;
&lt;p&gt;版本差异: &lt;a href=&quot;https://github.com/containernetworking/cni/blob/master/SPEC.md&quot;&gt;Container Network Interface Specification&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="CloudNative" scheme="http://example.com/categories/CloudNative/"/>
    
    
    <category term="Kubernetes" scheme="http://example.com/tags/Kubernetes/"/>
    
    <category term="CNI" scheme="http://example.com/tags/CNI/"/>
    
  </entry>
  
</feed>
